
###################################################################################
#
# BenchTest_Machine_Learning_Framework
#
# Designed to allow multiple models to be built and deployed without change
#
# Supports: Random Forrest, KNN, SVM, GLM, and Neuralnetwork models
#           SpecialModel can be used if a new model is to be tested
#
###################################################################################
#
# Aims: Reduce errors in machine learning, and deployment tasks
#
# By B. G. Bland 
#
# Notes: All librarys added on demand - If only Random Forrest model required
#        then only the random forrest package needs to be installed and loaded
#        by the script
#
# User Code Required: 
#
#        Function - SetDataLoadParameters - Include any parameters that 
#                                           control what data is loaded, and how
#                                           (Optional for quick analysis)
#
#        Function - SetParameters - Use this to switch model used and hyper parameters
#                                   used by the model for training
#
#        Function - DataLoadAndFormat - Load in the data required
#
#        Function - ProcessPredictions - Use to further post process predictions made
#
###################################################################################

set.seed(50) # Forces same random number to be produced

# Example Framework code
rm(list=ls())

# User editable function - Add data loading parameters here ...
SetDataLoadParameters <- function(Debug=TRUE)
{
  
  if (Debug==TRUE) {print("Setting Data Load Parameters")}
  
  ################################################################################
  # Add all the additional parameters needed to load data here (eg Instrument) ...
  
  DataLoadParameters = list()
  DataLoadParameters$Example = "Example Data Load parameter"
  
  ################################################################################
  
  if (Debug==TRUE) {print("Finished Setting Data Load Parameters")}
  
  return(DataLoadParameters)
}

# Function to ensure no global variables are used within the Machine Learning Functions
#
# User define your own parameters here
#
SetParameters <- function(Debug=TRUE)
{
  
  if (Debug==TRUE) {print("Setting up model parameters")}
  
  #################################################################################
  # Set all model parameters here
  
  # ML Params
  MLParameterList = list()
  
  # Data Pre processing option
  MLParameterList$ConvertToFactors     <- TRUE           
  MLParameterList$OneHotEncodeFactors  <- TRUE            # Use for neural networks
  
  MLParameterList$AutoScaling          <- TRUE            # Note: Should not be used except for model evaluation
  # as knowledge of max and mins will effect predictions
  # Automatically scales returning max and mins
  # Affected by autoscaling
  
  MLParameterList$ProjectTitle               <- "Calibration"
  MLParameterList$ColumnsToSelectForTraining <- c("StraightLine","SineWave","WavySineWave") # Reduce data set from original
  #MLParameterList$ColumnsToSelectForTraining <- c("CosX") # USe prediction variable when AutoScaling = TRUE
  
  MLParameterList$Rescale                    <- TRUE             # Rescale all the values (must be one hot encoded)
  MLParameterList$Maximums                   <- c(10,2,2)       # Max values for each variable
  MLParameterList$Minimums                   <- c(-1,-2,-2)      # Min value for each variable
  
  # Prediction variable
  MLParameterList$PredictionVariable        <- "Rape"                                          # y^ the prediction variable
  MLParameterList$DisplayColumnNames        <- MLParameterList$ColumnsToSelectForTraining
  MLParameterList$VariableNames             <- setdiff(MLParameterList$DisplayColumnNames,MLParameterList$PredictionVariable)
  
  # Sampling method
  MLParameterList$SamplingMethod            <- TRUE  # WARNING : Set to false for time series data
  MLParameterList$SaveModelToFile           <- TRUE
  MLParameterList$FileNameOfModel           <- "ML_Model"
  
  # Regression Options
  MLParameterList$RegressionModel           <- "GLM"         # Can be SVM, RF, RFRLT, NN, KNN, XGB
  MLParameterList$SplitPercent              <- 80/100
  
  # RF Parameters
  MLParameterList$RegressionType            <- "regression"    # Use only regression or classification
  MLParameterList$NumberOfTrees             <- 200             # Decision tree models only
  
  # NeuralNet parameters
  MLParameterList$HiddenLayersStructure     <- c(30)           # Layers required for NN only (Nodes only for this model)
  MLParameterList$Iterations                <- 500             # Number of iterations
  
  # KNN parameters
  MLParameterList$K                         <- 20              # KNN only
  
  # Keras parameters (Note: Will not work well with small data sets)
  MLParameterList$Epochs                     = 50              # Number of training epochs - 50
  MLParameterList$BatchSize                  = 100             # Batch size                 - 128
  MLParameterList$ValidationSplit            = 0.2             # Split for validation
  
  # XGBoost
  MLParameterList$booster                    = "gbtree"        # Defaul = gbtree, or gblinear
  MLParameterList$max_depth                  = 6
  MLParameterList$eta                        = 0.3
  MLParameterList$gamma                      = 0
  MLParameterList$subsample                  = 0.5
  MLParameterList$nthread                    = 6
  MLParameterList$nrounds                    = 200
  MLParameterList$objective                  = "binary:logistic"  # "multi:softprob", or binary:logistic multi on works for many cols
  MLParameterList$verbose                    = TRUE
  
  # Load parameters
  MLParameterList$BackTest                  <- FALSE
  MLParameterList$Debug                     <- TRUE
  
  # Data Analysis Options
  MLParameterList$PrintExamplesinAnalysis   <- TRUE
  MLParameterList$DrawChartsinAnalysis      <- TRUE
  MLParameterList$DrawChartsOfResults       <- TRUE
  MLParameterList$DrawHistograms            <- FALSE
  MLParameterList$DrawVersusPlots           <- TRUE
  MLParameterList$DrawImportanceCharts      <- TRUE
  MLParameterList$DrawMissingValues         <- TRUE
  
  
  # Load ggplot library if charts are required
  if ((MLParameterList$DrawChartsinAnalysis == TRUE) || (MLParameterList$DrawChartsOfResults == TRUE) || (MLParameterList$DrawImportanceCharts == TRUE))
  {
    library(ggplot2)
  }
  
  ####################################################################################
  
  if (Debug==TRUE) {print("Finished setting up model parameters")}
  
  return(MLParameterList)
  
}


# Special theme for plotting AI Benchtest results
#

theme_AI <- function()
{
  
  palette <- c("#FFFFFF", "#F0F0F0", "#A7A8AA", "#BDBDBD", "#969696", "#16C5A8",
               "#525252", "#252525", "#000000")
  
  color.background = palette[1]
  color.grid.major = palette[3]
  color.axis.text = palette[7]
  color.axis.title = palette[7]
  color.title = palette[9]
  
  theme_bw(base_size=10) +
    
    theme(
      
      panel.background=element_rect(fill=color.background, color=color.background),
      plot.background=element_rect(fill=color.background, color=color.background),
      panel.border=element_rect(color=color.background),
      
      legend.position = "top",
      
      panel.grid.major=element_line(color=color.grid.major,size=.25),
      panel.grid.minor=element_blank(),
      
      axis.ticks=element_blank(),
      
      legend.background = element_rect(fill=color.background),
      legend.key = element_rect(fill=color.background, color=NA),
      legend.text = element_text(size=10,color=color.axis.title),
      
      plot.title=element_text(color=color.title, size=13, vjust=1.25),
      plot.subtitle=element_text(color=color.title, size=12, vjust=1.25),
      axis.text.x=element_text(size=10,color=color.axis.text),
      axis.text.y=element_text(size=10,color=color.axis.text),
      axis.title.x=element_text(size=11,color=color.axis.title, vjust=0),
      axis.title.y=element_text(size=11,color=color.axis.title, vjust=1.25),
      
      plot.margin  = unit(c(0.1, 0.1, 0.9, 0.1), "cm")
      
    )
  
}


# Function to lag data by any given time period
#
#
# DataFrame <- LagDataFrame(DataFrame=DataFrame,     # Data frame name
#                  Column="Latency",       # Name of the column to be adjusted
#                  Periods=2,        # Number of intervals to go backwards or forwards
#                  MissingValues=NA, # What do you want the missing values to be (use NA so you can remove with na.omit())
#                  KeepAll=TRUE,    # Create columns for all periods in between
#                 Backwards=TRUE)   # Set to true to create next values (ie n periods in the future)

LagDataFrame <- function(DataFrame="",
                         Column="",
                         Periods="",
                         MissingValues=NA,
                         KeepAll=TRUE,
                         Backwards=TRUE)
{
  # Select the column to be used
  NewData <- DataFrame[,Column]
  NewDataFrame <- DataFrame
  if (Backwards == TRUE)
  {
    ColNameExtension <- "_step_back"
  } else 
  {
    ColNameExtension <- "_step_forward"
  }
  
  # Now loop to get to the period required
  for (i in seq(1,Periods))
  {
    # Create new column to put lagged data into
    NewCol <- paste(Column,"_",i,ColNameExtension,sep="")
    
    # Now create the lagged data by 1 period back or forwards
    if (Backwards == TRUE)
    {
      NewData <- c(MissingValues,head(NewData,length(NewData)-1))
    } else {
      NewData <- c(tail(NewData,length(NewData)-1),MissingValues)
    }
    
    # Create new data frame with the column so we can add to the existing data frame
    NewColDataFrame <- as.data.frame(NewData)
    colnames(NewColDataFrame) <- c(NewCol)
    
    # Now store all the previous values or just keep the last one we got to
    if (KeepAll==TRUE)
    {
      NewDataFrame <- cbind(NewDataFrame,NewColDataFrame)
    } else {
      NewDataFrame <- cbind(DataFrame,NewColDataFrame)
    }
  }
  
  # Return the data frame
  return(NewDataFrame)
}



#####################################################################################
#
# Functions - Edit the Data Load and Format Function to ingest the data
#
#####################################################################################
# Function to load a check data 
#
DataLoadAndFormat <- function(Backtest=TRUE,Debug=TRUE,ConvertToFactors=FALSE,DataLoadParameters="")
{
  
  if (Debug==TRUE) {print("Loading data")}
  
  if (Debug==TRUE) {print(paste("Example data load parameter",DataLoadParameters$Example))}
  
  # Use example MTCARS data set
  DataFrame <- as.data.frame(mtcars)
  
  # Apply filters here
  DataFrame <- subset(DataFrame,hp > 60)   # Removes the small horsepower records
  
  if (ConvertToFactors==TRUE)
  {
    # Apply converstion to factors for columns required
    DataFrame$carb <- factor(DataFrame$carb)
    DataFrame$cyl <- factor(DataFrame$cyl)
    DataFrame$gear <- factor(DataFrame$gear)
    DataFrame$vs <- factor(DataFrame$vs)
    DataFrame$am <- factor(DataFrame$am)
  }
  
  print(head(DataFrame))
  
  return(DataFrame)
  
}


# Function to load a check data 
DataLoadAndFormat <- function(Backtest=TRUE,Debug=TRUE,ConvertToFactors=FALSE,DataLoadParameters="")
{
  if (Debug==TRUE) {print("Creating calibration data")}
  
  # Create an example test set for testing
  x <- seq(0,2*pi,by=0.005)
  Mean <- 0
  sd <- 0.1
  
  # A noisy straight line
  noise = rnorm(length(x),Mean,sd)
  StraightLine <- x + noise
  
  
  # A noisy sin wave
  noise = rnorm(length(x),Mean,sd)   
  SineWave <- sin(x) + noise
  
  
  # A wavy sine wave3
  noise = rnorm(length(x),Mean,sd)
  WavySineWave <- sin(x) + noise + (cos(x*x)/2)
  
  
  df <- data.frame(StraightLine=StraightLine,SineWave=SineWave,WavySineWave=WavySineWave)
  
  ResultsPlot <- ggplot(df,aes(x=x,y=StraightLine)) +
    geom_point(aes(x=x,y=StraightLine),
               colour="Blue",
               size=1) +
    geom_point(aes(x=x,y=SineWave),
               colour="Red",
               size=1) +
    geom_point(aes(x=x,y=WavySineWave),
               colour="Green",
               size=1) +
    xlab(paste("X")) +
    ylab(paste("Input Variables")) +
    ggtitle(paste("Input Data")) +
    theme_AI()
  
  print(ResultsPlot)
  
  DataFrame <- df
  
  if (Debug==TRUE) {print("Finished loading test data")}
  
  return(DataFrame)
  
}

# ISIS Data set
DataLoadAndFormat <- function(Backtest=TRUE,Debug=TRUE,ConvertToFactors=FALSE,DataLoadParameters="")
{
  if (Debug==TRUE) {print("Creating calibration data")}
  
  DataFrame = iris
  
  if (Debug==TRUE) {print("Finished loading test data")}
  
  return(DataFrame)
  
}

# USArrests Data set
DataLoadAndFormat <- function(Backtest=TRUE,Debug=TRUE,ConvertToFactors=FALSE,DataLoadParameters="")
{
  if (Debug==TRUE) {print("Creating calibration data")}
  
  DataFrame = USArrests
  
  if (Debug==TRUE) {print("Finished loading test data")}
  
  return(DataFrame)
  
}


# Capitalise the first leter of a string
CapitaliseFirstLetter <- function(s) {
  paste(toupper(substring(s, 1, 1)), substring(s, 2), sep = "")
}

# Auto scale the data frame but only for columns specified
AutoScale <- function(DataFrame = "",
                      Columns = "",
                      Debug=TRUE,
                      AllColumns=FALSE,
                      LogColumns="",
                      SqrtColumns="",
                      OneHotEncodeFactorColumns=FALSE)
{
  
  # Check something was specified
  if (DataFrame == "" || class(DataFrame) != "data.frame") {
    if (Debug==TRUE) {print("Must specify a data frame")}
  }
  
  
  # Set up a vector for max, mins and logs
  MaximumValues <- vector(mode = "logical", length = length(Columns))
  MinimumValues <- vector(mode = "logical", length = length(Columns))
  LoggedValues <- vector(mode = "logical", length = length(Columns))
  SqrtValues <- vector(mode = "logical", length = length(Columns))
  
  if (AllColumns == TRUE)
  {
    Columns <- colnames(DataFrame)
  }
  
  # First get the max and min values for the data frames columns
  i <- 0
  for (Column in Columns)
  {
    
    i <- i + 1
    
    # Get the column from the list
    DataColumn <- DataFrame[,Column]
    
    # Ignore columns that are factors
    if (is.factor(DataColumn) == FALSE)
    {
      if (Debug==TRUE) {print(paste("     ",Column,"is not a factor"))}
      LoggedValues[i] <- 0
      SqrtValues[i] <- 0
      
      if(Column %in% LogColumns == TRUE)
      {
        if (Debug==TRUE) {print(paste("     ",Column,"Will be logged (base 10) before scaling"))}
        DataColumn <- log10(DataColumn)
        LoggedValues[i] <- 1
      }
      if(Column %in% SqrtColumns == TRUE)
      {
        if (Debug==TRUE) {print(paste("     ",Column,"Will be square rooted before scaling"))}
        DataColumn <- sqrt(DataColumn)
        SqrtValues[i] <- 1
      }
      
      MaximumValues[i] <- max(DataColumn)
      MinimumValues[i] <- min(DataColumn)
      
      if (Debug==TRUE) {print(paste("     ",Column,"has max",MaximumValues[i],"and min",MinimumValues[i]))}
      
      DataFrame[,Column] <- scale(DataColumn,center = MinimumValues[i],scale = MaximumValues[i] - MinimumValues[i])
      
    } else {
      if (Debug==TRUE) {print(paste("     ",Column,"is a factor so will not be changed"))}
      
    }
    
  }
  
  # One hot encode all the factor columns
  if (OneHotEncodeFactorColumns == TRUE)
  {
    # First refactor all the factor columns
    DataFrame <- as.data.frame(lapply(DataFrame, function (x) if (is.factor(x)) factor(x, ordered = FALSE) else x)) 
    
    # One hot encode all the data in the data frame
    DataFrame = as.data.frame(model.matrix(~.-1,DataFrame))    # Convert to matrix
    
    # Remove spaces from the column names and replace with little x
    names(DataFrame) <-gsub(" ","..", names(DataFrame))
    names(DataFrame) <-gsub("\\^","..", names(DataFrame))
  }
  
  # Returns modified data frame and max and min values
  return(list(DataFrame,MaximumValues,MinimumValues,LoggedValues,SqrtValues,Columns))
  
}

# Outlier removal function
# Uses supsmu for non-seasonal series and a periodic stl decomposition with 
# seasonal series to identify outliers and estimate their replacements.
# Example:
# HistoricExampleData <- OutlierRemoval(DataFrame=HistoricExampleData,
#                                      Column="Ratio",
#                                      DrawOutlierChart = TRUE,
#                                      Debug=TRUE,
#                                      UseLastn = 250)

OutlierRemoval <- function(DataFrame="",Column="",DrawOutlierChart=TRUE,Debug=TRUE,UseLastn="")
{
  
  if (Debug == TRUE) {print("Starting outlier removal")}
  
  # LOad required library
  library("tsoutliers")
  
  #Ensure that the data frame is really a data frame
  DataFrame <- as.data.frame(DataFrame)
  
  DataFrame <- tail(DataFrame,UseLastn)
  
  # Extract the column we require
  TimeSeriesColumn <- DataFrame[,Column]
  
  # The function ts is used to create time-series object from column
  dat.ts <- ts(TimeSeriesColumn,frequency=1)
  
  # Now process the outliers
  data.ts.outliers <- tso(dat.ts)
  
  if (Debug == TRUE) {print(data.ts.outliers)}
  
  if (DrawOutlierChart == TRUE)
  {
    plot(data.ts.outliers)
  }
  
  # Now add the outlier information back to the data frame
  
  # First get the Outliers
  OutlierEffects <- data.ts.outliers$effects
  
  # If we did not find any
  if(is.null(OutlierEffects)==FALSE)
  {
    # Get the adjusted values
    AutoAdjusted <- data.ts.outliers$yadj
    
    # Change the column headings to allow for multiple columns to be used
    NewDF <- data.frame(OutlierEffects,AutoAdjusted)
    colnames(NewDF) <- paste(Column,"_",colnames(NewDF), collapse = NULL,sep="")
    
    # Add the new columns
    DataFrame <- cbind(DataFrame,NewDF)
  } else {
    print(paste("No outliers were found on this column",Column))
    
    # Creating a adjusted column which is equal to the original
    NewDF <- data.frame(OutlierEffects=0,AutoAdjusted=TimeSeriesColumn)
    colnames(NewDF) <- paste(Column,"_",colnames(NewDF), collapse = NULL,sep="")
    
    # Add the new columns
    DataFrame <- cbind(DataFrame,NewDF)
  }
  
  if (Debug == TRUE) {print("Finished outlier removal")}
  
  return(DataFrame)
  
}


# Outlier removal function using iqr or gesd methods
#
# NewDF <- OutlierRemovalSTL(DataFrame=btc,
#                           DateColumn="Date",
#                           Column="Close",
#                           DrawOutlierChart=TRUE,
#                           Debug=TRUE,
#                           UseLastn=500,
#                           ChartTitle = "TSLA.US",
#                           Method = "gesd",
#                           PercentAnomalies = 1)

OutlierRemovalSTL <- function(DataFrame="",
                              DateColumn="",
                              Column="",
                              DrawOutlierChart=TRUE,
                              Debug=TRUE,
                              UseLastn="",
                              ChartTitle="",
                              Method = "iqr",
                              PercentAnomalies = 1)
{
  
  if (Debug == TRUE) {print("Starting outlier removal")}
  
  library(anomalize) #tidy anomaly detectiom
  library(tidyverse) #tidyverse packages like dplyr, ggplot, tidyr
  library(tibbletime)
  
  #Ensure that the data frame is really a data frame
  DataFrame <- as.data.frame(DataFrame)
  
  # Remove the end of it as required
  DataFrame <- tail(DataFrame,UseLastn)
  
  # Extract the column we require
  DateSeriesColumn <- DataFrame[,DateColumn]
  TimeSeriesColumn <- DataFrame[,Column]
  
  # Create a data frame
  btc <- data.frame(Price=ts(TimeSeriesColumn),date=DateSeriesColumn)
  
  # Anomalies
  timedecomp <- time_decompose(as.tibble(btc),Price, method = "stl", frequency = "auto", trend = "auto") 
  Anoms <-  tryCatch({
    anomalize(timedecomp,remainder, method = Method, max_anoms = (PercentAnomalies/100)) # gesd or iqr
  } , warning = function(w) {
    # warning-handler-code
  }, error = function(e) {
    #  error-handler-code
  }, finally = {
    # cleanup-code
  })
  
  # If we found some
  if (is.null(Anoms) == FALSE)
  {
    Anoms$Anom <- ifelse(Anoms$anomaly == "Yes",1,NA)
    Anoms$Adjusted <- ifelse(Anoms$anomaly == "Yes",Anoms$trend,Anoms$observed)
    
    if (DrawOutlierChart == TRUE)
    {
      
      library(ggplot2)
      ResultsPlot1 <- ggplot(Anoms,aes(x=date,y=observed)) +
        geom_step(aes(x=date,y=observed),
                  colour="Blue",
                  size=1,
                  alpha=1) +
        geom_step(aes(x=date,y=Adjusted),
                  colour="Orange",
                  size=1,
                  alpha=1) +
        geom_step(aes(x=date,y=trend),
                  colour="Green",
                  size=0.5) + 
        geom_point(aes(x=date,y=observed*Anom),
                   colour="Red",
                   size=1) + 
        xlab(paste(DateColumn)) +
        ylab(paste(Column)) +
        theme_AI() +
        ggtitle(paste(ChartTitle,DateColumn,Column))
      
      ResultsPlot2 <- ggplot(Anoms,aes(x=date,y=observed)) +
        geom_step(aes(x=date,y=remainder),
                  colour="Red",
                  size=0.5) + 
        xlab(paste(DateColumn)) +
        ylab(paste("Remander")) +
        theme_AI() +
        ggtitle(paste("Remainder"))
      
      library(gridExtra)
      grid.arrange(ResultsPlot1,ResultsPlot2)
      
    }
    
    
    # Creating a adjusted column which is equal to the original
    NewDF <- data.frame(Trend=Anoms$trend,AutoAdjusted=Anoms$Adjusted,Remainder=Anoms$remainder)
    colnames(NewDF) <- paste(Column,"_",colnames(NewDF), collapse = NULL,sep="")
    
    # Add the new columns
    DataFrame <- cbind(DataFrame,NewDF)
    
  } else {
    
    print(paste("No outliers were found on this column, try changing PercentAnomalies to be higher",Column))
    
    # Creating a adjusted column which is equal to the original
    NewDF <- data.frame(Trend=NA,AutoAdjusted=NA,Remainder=NA)
    colnames(NewDF) <- paste(Column,"_",colnames(NewDF), collapse = NULL,sep="")
    
    # Add the new columns
    DataFrame <- cbind(DataFrame,NewDF)
  }
  
  if (Debug == TRUE) {print("Finished outlier removal")}
  
  return(DataFrame)
  
}


# BreakdownDateTime() - Breaks form a datetime column into all possible training selections
# Note: Format must match input date time format
#
# NewDF <- BreakdownDateTime(DataFrame=HistoricExampleData1,
#                           Column="Date",
#                           BreakdownDates=TRUE, 
#                           BreakdownTimes=FALSE,
#                           DateFormat = "%Y-%m-%d",
#                           Debug=TRUE)

BreakdownDateTime <- function(DataFrame="",
                              Column="",
                              BreakdownDates=TRUE, 
                              BreakdownTimes=TRUE,
                              DateFormat = "%Y%m%d %H:%M:%",
                              Debug=TRUE)
{
  if (Debug == TRUE) {print("Starting date time breakdown")}
  
  # Load required library
  library(lubridate)
  
  #Ensure that the data frame is really a data frame
  DataFrame <- as.data.frame(DataFrame)
  
  # Extract the column we require
  DateTimeColumn <- as.character(DataFrame[,Column])
  
  # Convert to date time
  DateTimeColumn <- fast_strptime(DateTimeColumn,DateFormat)
  DateColumn <- as.Date(DateTimeColumn)
  
  # Extract the Date
  if (BreakdownDates == TRUE)
  {
    DateOnly <- date(DateColumn)
    Year <- year(DateColumn)
    Month <- month(DateColumn)
    DayOfMonth <- day(DateColumn)
    Weekday <- wday(DateColumn)
    WeekOfYear <- week(DateColumn)
    DayOfQuarter <- qday(DateColumn)
    Quarter <- quarter(DateColumn)
    LeapYear <- leap_year(DateColumn)
    
    # Change the column headings to allow for multiple columns to be used
    NewDF <- data.frame(DateOnly,
                        Year,
                        Month,
                        DayOfMonth,
                        Weekday,
                        WeekOfYear,
                        DayOfQuarter,
                        Quarter,
                        LeapYear)
    
    # Change the column names to make them standard
    colnames(NewDF) <- paste(Column,"_",colnames(NewDF), collapse = NULL,sep="")
    
    # Add the new columns
    DataFrame <- cbind(DataFrame,NewDF)
  }
  
  # Extract the Times
  if (BreakdownTimes == TRUE)
  {
    Is_AM <- am(DateTimeColumn)
    Is_PM <- pm(DateTimeColumn)
    Hour <- hour(DateTimeColumn)
    Minute <- minute(DateTimeColumn)
    Second <- second(DateTimeColumn)
    
    # Change the column headings to allow for multiple columns to be used
    NewDF <- data.frame(Is_AM,
                        Is_PM,
                        Hour,
                        Minute,
                        Second)
    
    # Change the column names to make them standard
    colnames(NewDF) <- paste(Column,"_",colnames(NewDF), collapse = NULL,sep="")
    
    # Add the new columns
    DataFrame <- cbind(DataFrame,NewDF)
  }
  
  if (Debug == TRUE) {print("Finish date time breakdown")}
  
  return(DataFrame)
  
}


ProcessPredictions <- function(TrainingPredictions,TestingPredictions,DataFrame,DataLoadParameters)
{
  # Put post process function in here
  #print(head(TestingPredictions),3)
  return(TestingPredictions)
  
}

# Used in data analysis function to display the max and mins 
# found in the training data set
DataFrameMaxAndMins <- function(DataFrame)
{
  
  # Compute the max and mins for each column in the data frame
  Columns <- colnames(DataFrame)
  maxs <- apply(DataFrame, 2, max) 
  mins <- apply(DataFrame, 2, min)
  
  return(list(ColumnNames=Columns,Maximums=maxs,Minimums=mins))
  
}

OrderlyExit <- function(Reason="",Description="",Fix="")
{
  print("----------------------------------------------")
  print("-----------ERROR OCCURED IN FRAMEWORK --------")
  print("----------------------------------------------")
  print(Reason)
  print(Description)
  print(Fix)
  print("----------------------------------------------")
  stop()
}

# Used to check which columns are outside of the required range
CheckDataFrameMaxAndMinsWithinRange <- function(DataFrame,MinAllowed,MaxAllowed,Debug=FALSE)
{
  
  if (Debug==TRUE) {print(paste("Starting DataFrame Max and Mins check"))}
  
  
  # Compute the max and mins for each column in the data frame
  Columns <- colnames(DataFrame)
  maxs <- apply(DataFrame, 2, max) 
  mins <- apply(DataFrame, 2, min)
  
  ResultsDataFrame <- data.frame(Max=maxs,Min=mins)
  rownames(ResultsDataFrame) = Columns
  
  ResultsDataFrame$MaxOK <- ifelse(ResultsDataFrame$Max <= MaxAllowed,0,1)
  ResultsDataFrame$MinOK <- ifelse(ResultsDataFrame$Min >= MinAllowed,0,1)
  
  if (Debug==TRUE) {print(ResultsDataFrame)}
  
  if (sum(ResultsDataFrame$MaxOK) > 0 || sum(ResultsDataFrame$MinOK) > 0)
  {
    OrderlyExit(Reason = "Max or minimum values outside of models permitted values",
                Description = paste("Min values",MinAllowed,"and max values of",MaxAllowed),
                Fix = "Check Autoscaling is enabled, or you have set the max and min vectors correctly")
  }
  
  if (Debug==TRUE) {print(paste("Finished DataFrame Max and Mins check"))}
  
  return(TRUE)
  
}

## Quick summary of data we are using to compute the column type and number of levels
DataAnalysis <- function(DataFrame,
                         PredictionVariable="",
                         Title = "",
                         PrintExamples = TRUE,
                         DrawCharts = TRUE,
                         DrawHistograms = TRUE,
                         DrawVersusPlots = TRUE,
                         DrawMissingValues = FALSE,
                         Debug=TRUE)
{
  if (Debug==TRUE) {print("Data Analysis of DataFrame")}
  if (Debug==TRUE) {print("")}
  
  if (is.data.frame(DataFrame) == TRUE)
  {
    # Print missing data
    if (DrawMissingValues == TRUE)
    {
      if (nrow(DataFrame < 1000))
      {
        library(Amelia)
        missmap(DataFrame, main = "Missing values vs observed")
      }
    }
    Cols <- colnames(DataFrame)
    
    for (col in Cols)
    {
      
      # Select the column number
      ColNo <- which(Cols == col)
      if (Debug==TRUE) {print(paste("Column",col))}
      if (Debug==TRUE) {print(paste("    No unique values =",length(unique(DataFrame[,ColNo]))))}
      if (Debug==TRUE) {print(paste("    Class",class(DataFrame[,ColNo]),"with",length(levels(DataFrame[,ColNo])),"levels"))}
      
      # Print top five unique items
      if (PrintExamples == TRUE)
      {
        # Now print the top 5 unique values in the column
        for (i in head(unique(DataFrame[,ColNo]),5)){print(paste("        ",col,"=",i))}
      }
      
      # Now print summary if not a factor
      if (class(DataFrame[,ColNo])!= "factor") {
        if (Debug==TRUE) {print(paste("    Min",min(DataFrame[,ColNo]),
                    "Median",median(DataFrame[,ColNo]),
                    "Mean",mean(DataFrame[,ColNo]),
                    "Max",max(DataFrame[,ColNo])))}
      }
      
      if (Debug==TRUE) {print(" ")}
      
      if (DrawCharts == TRUE)
      {
        if (col != PredictionVariable)
        {
          # Now plot the results
          Prediction <- which(Cols == PredictionVariable)
          PredictionCol <- DataFrame[,Prediction]
          ActualCol <- DataFrame[,ColNo]
          PlotDF <- data.frame(Prediction = PredictionCol, Actual = ActualCol)
          
          if (DrawVersusPlots == TRUE)
          {
            ResultsPlot <- ggplot(PlotDF,aes(x=Actual,y=Prediction)) +
              geom_point(aes(x=Actual,y=Prediction),
                         colour="Blue",
                         fill="DarkBlue",
                         size=0.5) +
              geom_smooth(method="lm") +
              ylab(paste(PredictionVariable,"- Predict Column")) +
              xlab(paste(col,"- Example Column")) +
              theme_AI() +
              ggtitle(paste(Title,"-",PredictionVariable,"versus",col))
            print(ResultsPlot)
          }
        }
        
        if (DrawHistograms == TRUE)
        {
          # Now plot the histograms
          ResultsPlot <- ggplot(PlotDF,aes(x=Actual)) +
            geom_histogram(aes(x=Actual),
                           colour="Blue",
                           fill="DarkBlue",
                           size=0.5) +
            ylab(paste("Count")) +
            xlab(paste(col,"- Example Column")) +
            theme_AI() +
            ggtitle(paste(Title,"-","Histogram",col))
          print(ResultsPlot)
        } 
      }
    }
    
  }
}



# Split function
SplitData <- function(DataFrame,PercentToSplit,SplitUsingSampleMethod=TRUE,Debug=TRUE)
{
  # Will add index column
  DataFrame$x <- seq(1,nrow(DataFrame))
  
  ## Number of rows to sample
  smp_size <- floor(PercentToSplit * nrow(DataFrame))
  
  if (Debug == TRUE) {print(paste("Using training sample size of",smp_size,"using",PercentToSplit,"% split"))}
  if (Debug == TRUE) {print(paste("From total data set of",nrow(DataFrame),"rows"))}
  
  if (SplitUsingSampleMethod == TRUE)
  {
    
    if (Debug == TRUE) {print("Using sampling method to select training data")}
    
    # Create sampling index
    train_ind <- sample(DataFrame$x, size = smp_size)
    
    # Now split te data into training and test
    train <- DataFrame[train_ind, ]
    test <- DataFrame[-train_ind, ]
    
  } else {
    
    if (Debug == TRUE) {print("Using first n% to select training data")}
    
    # Use the first percentage and test with the remaining
    train <- DataFrame[1:smp_size,]
    test <- DataFrame[(smp_size+1):nrow(DataFrame),]
    
  }
  
  # Check nrows of both
  if (Debug == TRUE) {print(paste("Number of rows in training set ... ",nrow(train)))}
  if (Debug == TRUE) {print(paste("Number of rows in testing set ... ",nrow(test)))}
  
  
  # Now remove the x variable
  train$x <- NULL
  test$x <- NULL
  
  # Return list of data frames
  ReturnList <- list(train,test)
  
  return(ReturnList)
}

# Function to pre-process the data - First selects columns, then rescales, then splits
PreProcess <- function(DataFrame,
                       Columns = "",
                       ColumnNames = "",
                       Backtest=TRUE,
                       Debug=TRUE,
                       PercentageToSplit=0,
                       UseSampleMethod=TRUE,
                       OneHotEncodeFactors=FALSE,
                       Rescale=FALSE,
                       MaxValues="",
                       MinValues="",
                       AutoScalingOn = FALSE)
{
  
  
  if (Debug==TRUE) {print("Started pre-processing data")}
  if (Debug==TRUE) {print(paste("    Using columns",Columns))}
  if (Debug==TRUE) {print(paste("    Using new column names of",ColumnNames))}
  if (Debug==TRUE) {print(paste("    Number of columns in data frame is",ncol(DataFrame)))}
  if (Debug==TRUE) {print(paste("    Number of rows in data frame is",nrow(DataFrame)))}
  if (Debug==TRUE) {print(paste("    Backtest switch is",Backtest))}
  
  
  if (AutoScalingOn == TRUE)
  {
    if (Debug==TRUE) {print("****** Autoscaling data **********")}
    
    # or this is you want all columns scaled with no log or sqrt functions applied
    ScaledDataFrame <- AutoScale(DataFrame = DataFrame,
                                 Columns = ColumnNames,      # eg c("Sepal.Length","Sepal.Width","Petal.Length","Petal.Width")
                                 Debug=Debug,
                                 AllColumns = TRUE,
                                 LogColumns = "",   # eg c("Sepal.Width")
                                 SqrtColumns = "",
                                 OneHotEncodeFactorColumns = OneHotEncodeFactors)
    # Extract the auto scaled data and save the max and mins used
    DataFrame <- ScaledDataFrame[[1]]
    Maximums <- ScaledDataFrame[[2]]
    Minimums <- ScaledDataFrame[[3]]
    ColumnsToSelectForTraining <- ScaledDataFrame[[6]]
    
  } else {
    
    # We are not auto scaling so we must use the values given
    
    # Generic code
    DataFrame <- DataFrame[,Columns]
    colnames(DataFrame) <- ColumnNames
    
    
    # Rescale all data using provided max and mins
    if (Rescale == TRUE)
    {
      if (Debug==TRUE) {print("    Rescaling data now")}
      
      i <- 0
      for (Column in colnames(DataFrame))
      {
        i <- i + 1
        DataColumn <- DataFrame[,Column]
        if (is.factor(DataColumn) == FALSE)
        {
          print(paste("     ",Column,"is not a factor"))
          Max <- MaxValues[i]
          Min <- MinValues[i]
          print(paste("     ",Column,"has max",Max,"and min",Min))
          DataFrame[,Column] <- scale(DataColumn,center = Min,scale = Max - Min)
          
        }
      }
      
    }
    
    # One hot encode all factors now
    if (OneHotEncodeFactors == TRUE)
    {
      if (Debug==TRUE) {print("    One hot encoding data now")}
      
      # First refactor all the factor columns
      DataFrame <- as.data.frame(lapply(DataFrame, function (x) if (is.factor(x)) factor(x) else x)) 
      
      # One hot encode all the data in the data frame
      DataFrame = as.data.frame(model.matrix(~.-1,DataFrame))    # Convert to matrix
      
      # Remove spaces from the column names and replace with little x
      names(DataFrame) <-gsub(" ","x", names(DataFrame))
      
    }
    
    # Copy the incoming ones so we can pass them back
    Maximums <- MaxValues
    Minimums <- MinValues
    ColumnsToSelectForTraining <- Columns
    
  }  
  
  # Split data
  ListOfDataFrames <- SplitData(DataFrame,PercentToSplit=PercentageToSplit,SplitUsingSampleMethod=UseSampleMethod,Debug=Debug)
  
  ListOfDataFrames$Maximums <- Maximums
  ListOfDataFrames$Minimums <- Minimums
  ListOfDataFrames$ColumnsToSelectForTraining <- ColumnsToSelectForTraining
  ListOfDataFrames$VariableNames <- ColumnsToSelectForTraining
  ListOfDataFrames$DisplayColumnNames <- ColumnsToSelectForTraining
  
  return(ListOfDataFrames)
  
}

####################################
#
# SpecialModel
#
####################################
TrainingModelSpecialModel <- function(DataFrame,
                             ColumnNames,
                             PredictVariable="",
                             Backtest=TRUE,
                             Debug=TRUE,
                             SaveModel=FALSE,
                             PlotImportance=TRUE,
                             FileName = "Model")
{
  if (Debug==TRUE) {print("Training on data using SpecialModel Model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  DataFrame <- cbind(VariableColumns,PredictVariable)
  
  #Print the SpecialModel parameters here ...
  # eg if (Debug==TRUE) {print(paste("    Link = ",Link))}
  
  # Train
  if (MLParameterList$RegressionType != "regression")
  {
    Model = glm(PredictVariable ~ . ,
                data = DataFrame,
                family=binomial(link='logit'))
  } else {
    Model = glm(PredictVariable ~ . ,
                family=gaussian(link="log"),
                data = DataFrame)
  }        
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_SpecialModel.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_SpecialModel.rds",sep=""))}
  }
  
  
  # Additional analysis goes here
  #
  
  return(Model)
  
}

PredictSpecialModel <- function(DataFrame,
                       ColumnNames,
                       Model,
                       type = "",
                       Backtest=TRUE,
                       Debug=TRUE,
                       LoadModel=FALSE,
                       FileName="Model",
                       PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from model and data using SpecialModel Model")}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_SpecialModel.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_SpecialModel.rds",sep=""))}
  }
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  DataFrame$Prediction <- predict(Model,VariableColumns)
  
  return(DataFrame)
}


####################################
#
# GLM
#
####################################
TrainingModelGLM <- function(DataFrame,
                            ColumnNames,
                            PredictVariable="",
                            Link="logit",
                            Backtest=TRUE,
                            Debug=TRUE,
                            SaveModel=FALSE,
                            PlotImportance=TRUE,
                            FileName = "Model")
{
  if (Debug==TRUE) {print("Training on data using GLM Model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  library(randomForest)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  DataFrame <- cbind(VariableColumns,PredictVariable)
  
  #Print the fitting parameters
  if (Debug==TRUE) {print(paste("    Link = ",Link))}
  
  # Train
  if (MLParameterList$RegressionType != "regression")
  {
      Model = glm(PredictVariable ~ . ,
                       data = DataFrame,
                       family=binomial(link='logit'))
  } else {
    Model = glm(PredictVariable ~ . ,
                data = DataFrame)
  }                   
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_GLM.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_GLM.rds",sep=""))}
  }
  
  
  # Additional analysis goes here
  #
  
  return(Model)
  
}

PredictGLM <- function(DataFrame,
                      ColumnNames,
                      Model,
                      type = "reposnse",
                      Backtest=TRUE,
                      Debug=TRUE,
                      LoadModel=FALSE,
                      FileName="Model",
                      PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from model and data using GLM Model")}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_GLM.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_GLM.rds",sep=""))}
  }
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  DataFrame$Prediction <- predict(Model,VariableColumns)
  
  return(DataFrame)
}


#################################
#
#  RF
#
#################################

TrainingModelRF <- function(DataFrame,
                            ColumnNames,
                            PredictVariable="",
                            NTrees=5,
                            Backtest=TRUE,
                            Debug=TRUE,
                            SaveModel=FALSE,
                            PlotImportance=TRUE,
                            FileName = "Model")
{
  if (Debug==TRUE) {print("Training on data using RF Model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  library(randomForest)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  DataFrame <- cbind(VariableColumns,PredictVariable)
  
  #Print the fitting parameters
  if (Debug==TRUE) {print(paste("    Number of trees = ",NTrees))}
  
  # Train
  Model = randomForest(PredictVariable ~ . ,
                       data = DataFrame,
                       keep.forest=TRUE,
                       importance=TRUE,
                       ntree = NTrees)
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_RF.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_RF.rds",sep=""))}
  }
  
  # Plot importance
  if (PlotImportance == TRUE) {ImportancePlot(Model,"Example Importance Plot","")}
  
  return(Model)
  
}

PredictRF <- function(DataFrame,
                      ColumnNames,
                      Model,
                      Backtest=TRUE,
                      Debug=TRUE,
                      LoadModel=FALSE,
                      FileName="Model",
                      PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from model and data using RF Model")}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_RF.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_RF.rds",sep=""))}
  }
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  DataFrame$Prediction <- predict(Model,VariableColumns)
  
  return(DataFrame)
}


###

TrainingModelRFRLT <- function(DataFrame,
                               ColumnNames,
                               PredictVariable="",
                               NTrees=10,
                               Backtest=TRUE,
                               Debug=TRUE,
                               SaveModel=FALSE,
                               PlotImportance=TRUE,
                               RegType="",
                               FileName = "Model")
{
  if (Debug==TRUE) {print("Training on data using RFRLT model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  if (Debug==TRUE) {print(paste("Using No Tress ....",NTrees))}
  if (Debug==TRUE) {print(paste("Using model ....",RegType))}
  
  library(RLT)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  if (RegType!="regression"){
    PredictVariable <- as.factor(PredictVariable)
  }
  
  # Run model
  Model = RLT(VariableColumns, PredictVariable,
              model = RegType, #  regression, classification or survival 
              use.cores = 7,
              ntrees = NTrees,
              importance = PlotImportance, 
              reinforcement = FALSE,   # setting to true gives better results but very slow
              combsplit = 20,
              embed.ntrees = NTrees)
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_RF_RLT.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_RF_RLT.rds",sep=""))}
  }
  
  # Plot importance
  if (PlotImportance == TRUE) {barplot(Model$VarImp)}
  
  return(Model)
  
}

PredictRFRLT <- function(DataFrame,
                         ColumnNames,
                         Model,
                         Backtest=TRUE,
                         Debug=TRUE,
                         LoadModel=TRUE,
                         FileName="Model",
                         PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from RF RLT model and data")}
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_RF_RLT.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_RF_RLT.rds",sep=""))}
  }
  
  PredictionList <- predict(Model,VariableColumns)
  
  DataFrame$Prediction <- PredictionList[[2]]   # Select only the predictions
  
  return(DataFrame)
  
}

TrainingModelSVM <- function(DataFrame,
                             ColumnNames,
                             PredictVariable="",
                             Backtest=TRUE,
                             Debug=TRUE,
                             SaveModel=FALSE,
                             PlotImportance=TRUE,
                             FileName="Model")
{
  
  if (Debug==TRUE) {print("Training on data using Support Vector Machine")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  library(e1071)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  Model <- svm(VariableColumns, 
               PredictVariable,
               type="eps-regression", #  C-classification for classification
               verbosity=0)   
  
  if (PlotImportance==TRUE)
  {
    print(summary(Model))
  }
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_SVM.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_SVM.rds",sep=""))}
  }
  
  return(Model)
  
}


PredictSVM <- function(DataFrame,ColumnNames,Model,
                       Backtest=TRUE,
                       Debug=TRUE,
                       LoadModel=FALSE,
                       FileName="Model",
                       PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from data using Support Vector Machine model")}
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_SVM.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_SVM.rds",sep=""))}
  }
  
  PredictionList <- predict(Model,VariableColumns)
  
  DataFrame$Prediction <- PredictionList   
  
  return(DataFrame)
  
}

# Call neural network and return the model of the network
TrainingModelNN <- function(DataFrame,
                            ColumnNames="",
                            PredictVariable="",
                            HiddenNodes="",
                            Backtest=TRUE,
                            Debug=TRUE,
                            SaveModel=TRUE,
                            FileName = "",
                            Iterations = 0)
{
  
  library(neuralnet)
  library(nnet)
  
  
  HiddenLayers <- paste(HiddenNodes,collapse=",")
  if (Debug==TRUE) {print(paste("Training on data using hidden layers of ",HiddenLayers))}
  
  # Get all column names minus the prediction variable
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  # Now create a df will both
  PredictVariableDF <- DataFrame[,PredictVariable]
  DataFrame <- cbind(VariableColumns,PredictVariableDF)
  
  n <- names(VariableColumns)
  
  f <- as.formula(paste("PredictVariableDF ~", paste(n[!n %in% PredictVariable], collapse = " + ")))
  
  Model = nnet(f,data=DataFrame,
               size=HiddenNodes,
               linout=T,
               decay=0.07,
               maxit=Iterations,
               trace=FALSE)
  
  #Model <- neuralnet(f,data=DataFrame,hidden=HiddenNodes,linear.output=T) # Linear.output = TRUE for regression
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_NeuralNetworkModel.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_NeuralNetworkModel.rds",sep=""))}
  }
  
  return(Model)
  
}

# Use model to predict results
# Take extreame care when editing this function to ensure no contamination of results
PredictNN <- function(DataFrame="",
                      PredictVariable="",
                      ColumnNames="",
                      Model,
                      Backtest=TRUE,
                      Debug=TRUE,
                      LoadModel=TRUE,
                      FileName = "")
{
  
  if (Debug==TRUE) {print("Predicting from model and data")}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_NeuralNetworkModel.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_NeuralNetworkModel.rds",sep=""))}
  }
  
  # Get all column names minus the prediction variable
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  #Results <- compute(Model,VariableColumns)
  Results = predict(Model, VariableColumns)
  
  DataFrame$Prediction <- Results  
  
  return(DataFrame)
  
}

TrainingModelKNN <- function(DataFrame,
                             ColumnNames,
                             PredictVariable="",
                             K=10,
                             Backtest=TRUE,
                             Debug=TRUE,
                             SaveModel=FALSE,
                             PlotImportance=TRUE,
                             RegType="",
                             FileName = "Model")
{
  if (Debug==TRUE) {print("Training on data using KNN model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  library(caret)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  # Run model
  Model = knnreg(VariableColumns, PredictVariable,k = K)
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_KNN.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_KNN.rds",sep=""))}
  }
  
  return(Model)
  
}

PredictKNN <- function(DataFrame,
                       ColumnNames,
                       Model,
                       Backtest=TRUE,
                       Debug=TRUE,
                       LoadModel=TRUE,
                       FileName="Model",
                       PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from KNN model and data")}
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_KNN.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_KNN.rds",sep=""))}
  }
  
  Prediction <- predict(Model, VariableColumns)
  
  DataFrame$Prediction <- Prediction   # Select only the predictions
  
  return(DataFrame)
  
}

TrainingModelXGBoost <- function(DataFrame,
                                 ColumnNames,
                                 PredictVariable="",
                                 Backtest=TRUE,
                                 Debug=TRUE,
                                 SaveModel=FALSE,
                                 PlotImportance=TRUE,
                                 RegType="",
                                 FileName = "Model")
{
  
  if (Debug==TRUE) {print("Training on data using XGBoost model")}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  OK <- CheckDataFrameMaxAndMinsWithinRange(DataFrame = DataFrame,MinAllowed = 0,MaxAllowed = 1,Debug=Debug)
  
  library(xgboost)
  
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  # Train
  Model <- xgboost(data = data.matrix(VariableColumns),
                   label = PredictVariable,
                   booster = MLParameterList$booster,     
                   max_depth = MLParameterList$max_depth,
                   eta = MLParameterList$eta,
                   gamma = MLParameterList$gamma,
                   subsample = MLParameterList$subsample,
                   nthread = MLParameterList$nthread,
                   nrounds = MLParameterList$nrounds,
                   objective = MLParameterList$objective,  
                   verbose = 0) # was MLParameterList$verbose
  
  if (PlotImportance == TRUE)
  {
    # Plot the top 10 variables
    importance_matrix <- xgb.importance(VariableNames, model = Model)
    xgb.plot.importance(importance_matrix[1:10,])
  }
  
  # Save model if required
  if (SaveModel == TRUE) {
    saveRDS(Model, paste(FileName,"_XGBoost.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_XGBoost.rds",sep=""))}
  }
  
  return(Model)
  
}

PredictXGBoost <- function(DataFrame,
                           ColumnNames,
                           Model,
                           Backtest=TRUE,
                           Debug=TRUE,
                           LoadModel=TRUE,
                           FileName="Model",
                           PredictVariable="")
{
  if (Debug==TRUE) {print("Predicting from XGBoost model and data")}
  
  #VariableColumns <- DataFrame[,ColumnNames]
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model = readRDS(paste(FileName,"_XGBoost.rds",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_XGBoost.rds",sep=""))}
  }
  
  # Predict
  Prediction <- predict(Model, data.matrix(VariableColumns))
  
  DataFrame$Prediction <- Prediction   # Select only the predictions
  
  return(DataFrame)
  
}

########################################
#
# KERAS Training Function
#
########################################

TrainingModelKeras <- function(DataFrame,
                               ColumnNames="",
                               PredictVariable="",
                               Backtest=TRUE,
                               Debug=TRUE,
                               SaveModel=FALSE,
                               FileName = "Model",
                               Type="classification",
                               Epochs=10,
                               BatchSize = 128,
                               ValidationSplit=0.2)
{
  
  library(keras)
  
  if (Debug==TRUE) {print(paste("Training on data using Keras model for type = ",Type))}
  if (Debug==TRUE) {print(paste("Predicting ....",PredictVariable))}
  if (Debug==TRUE) {print("Using Columns ....")}
  if (Debug==TRUE) {print(ColumnNames)}
  
  OK <- CheckDataFrameMaxAndMinsWithinRange(DataFrame = DataFrame,MinAllowed = 0,MaxAllowed = 1)
  
  # Select Cols required
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  # Convert to matrix
  VariableColumns <- as.matrix(VariableColumns)
  
  
  
  ## Creating the sequential model for classification
  CreateModelClassification <- function()
  {
    model = keras_model_sequential() %>%   
      layer_dense(units = 64, activation = "relu", 
                  input_shape = ncol(VariableColumns)) %>%
      layer_dense(units = 64, activation = "relu") %>%
      layer_dense(units = ncol(y_data_oneh), activation = "softmax")
    
    compile(model, 
            loss = "categorical_crossentropy",    
            optimizer = optimizer_rmsprop(), 
            metrics = "accuracy")
    
    return(model)
  }
  
  ## Creating the sequential model for regression
  CreateModelRegression <- function()
  {
    model <- keras_model_sequential() %>%
      layer_dense(units = 512, activation = "relu",
                  input_shape = dim(VariableColumns)[2],
                  kernel_initializer="normal") %>%
      layer_dense(units = 256, activation = "relu", kernel_initializer="normal") %>%
      layer_dense(units = 128, activation = "relu", kernel_initializer="normal") %>%
      layer_dense(units = 64, activation = "relu", kernel_initializer="normal") %>%
      layer_dense(units = 8, activation = "relu", kernel_initializer="normal") %>%
      layer_dense(units = 1, kernel_initializer="normal")
    
    model %>% compile(
      loss = "mse",
      optimizer = optimizer_adam(),
      metrics = list("mean_absolute_error")
    )
    
    
    return(model)
  }
  
  if (Type == "classification")
  {
    
    y_data_oneh=to_categorical(PredictVariable, num_classes = 2)
    print(head(y_data_oneh))
    model <- CreateModelClassification()
    
  }
  
  if (Type == "regression")
  {
    model <- CreateModelRegression()
    y_data_oneh = PredictVariable
  }
  
  # Fit model to data 
  history = fit(model,  VariableColumns, y_data_oneh, epochs = Epochs, batch_size = BatchSize, validation_split = ValidationSplit)
  plot(history)
  
  # Save model if required
  if (SaveModel == TRUE) {
    model %>% save_model_hdf5(paste(FileName,"_Keras.hdf5",sep=""))
    if (Debug==TRUE) {print(paste("    Saving to ",FileName,"_Keras.hdf5",sep=""))}
  }
  
  return(model)
  
}

########################################
#
# KERAS Prediction Function
#
########################################
PredictKeras <- function(DataFrame,
                         ColumnNames,
                         Model,
                         Backtest=TRUE,
                         Debug=TRUE,
                         LoadModel=FALSE,
                         FileName="Model",
                         PredictVariable="",
                         Type="Classification")
{
  if (Debug==TRUE) {print(paste("Predicting from model and data using Keras Model for",Type))}
  
  # Load Model required
  if (LoadModel == TRUE) {
    Model <- load_model_hdf5(paste(FileName,"_Keras.hdf5",sep=""))
    if (Debug==TRUE) {print(paste("    Loaded from ",FileName,"_Keras.hdf5",sep=""))}
  }
  
  VariableNames <- setdiff(colnames(DataFrame),PredictVariable)
  VariableColumns <- DataFrame[,VariableNames,drop=FALSE]
  
  # Convert to matrix
  VariableColumns <- as.matrix(VariableColumns)
  
  if (Type == "classification")
  {
    if (Debug==TRUE) {print(paste("Use predict classes to make predictions - ",Type))}
    DataFrame$Prediction = predict_classes(Model, VariableColumns)
  }
  
  if (Type == "regression")
  {
    if (Debug==TRUE) {print(paste("Use predict to make predictions - ",Type))}
    DataFrame$Prediction <- predict(Model, VariableColumns)
  }
  return(DataFrame)
  
}  


# Rescales and Handles the testing of the accuracy of fit
PostProcess <- function(DataFrame,
                        PredictVariable="",
                        Backtest=TRUE,
                        Debug=TRUE,
                        TestingSet=FALSE,
                        RegressionModel="",
                        Variable="",
                        RegType="",
                        DrawCharts = FALSE,
                        Rescale=FALSE,
                        MaxValues="",
                        MinValues="",
                        ColumnNames="")
{
  
  if (TestingSet == FALSE)
  {
    Item <- "Training Set"
    Title = paste("Training Data with",RegressionModel,"model predicting",Variable)
    if (Debug==TRUE) {print(paste("Post processing training data after running",RegressionModel,"model predicting",Variable))}
  } else {
    Item <- "Test Set"
    Title = paste("Testing Data with",RegressionModel,"model predicting",Variable)
    if (Debug==TRUE) {print(paste("Post processing testing data after running",RegressionModel,"model predicting",Variable))}
  }
  
  # Extract the predicted variable
  DataFrame$Actual <- DataFrame[,PredictVariable]
  
  # Now rescale the predicted variable if it was not a factor
  if (Rescale==TRUE)
  {
    if (Debug==TRUE) {print(paste("Rescaling prediction variable",PredictVariable))}
    
    # Find the prediction parameter in the columns list
    PredictCol <- which(ColumnNames==PredictVariable)
    
    # rescale now
    DataFrame$Prediction <- DataFrame$Prediction * (MaxValues[PredictCol] - MinValues[PredictCol]) + MinValues[PredictCol]
    DataFrame$Actual <- DataFrame$Actual * (MaxValues[PredictCol] - MinValues[PredictCol]) + MinValues[PredictCol]
  }
  
  # Handle x y type regression results
  if (RegType =="regression")
  {
    # reformat data
    DataFrame$Error <- DataFrame$Prediction - DataFrame$Actual
    
    # Calculate the RMSE and return it as part of the function
    RMSE <- sqrt(mean(DataFrame$Error^2))
    ReturnDataFrame <- data.frame(Desc=paste(Item,"RMS Error"),RMSE=RMSE)
    if (Debug==TRUE) {print(ReturnDataFrame)}
    
    if (DrawCharts == TRUE)
    {
      # Now plot the results
      ResultsPlot <- ggplot(DataFrame,aes(x=Actual,y=Prediction)) +
        geom_point(aes(x=Actual,y=Prediction),
                   colour="Blue",
                   fill="DarkBlue") +
        geom_smooth(method="lm") +
        xlab("Actual Value") +
        ylab("Prediction") +
        theme_AI() +
        ggtitle(paste("Actual versus Predicted - ",Title))
      print(ResultsPlot)
    }
  }
  
  # Handle classification problems
  if (RegType =="classification")
  {
    # Work out if not equal
    DataFrame$Error <- ifelse(DataFrame$Prediction == PredictVariable, 1, 0)
    if (Debug==TRUE) {print(DataFrame)}
    
    # find errors
    ErrorsFrame <- subset(DataFrame,DataFrame$Prediction != DataFrame$Actual)
    if (Debug==TRUE) {print(paste("Number of rows predicted",nrow(DataFrame)))}
    if (Debug==TRUE) {print(paste("Number of errors found",nrow(ErrorsFrame)))}
    
    ReturnDataFrame <- ErrorsFrame
    
  }
  
  if (Debug==TRUE) {print(paste("Returning dataframe with results"))}
  
  return(DataFrame)
  
}

ImportancePlot <- function(Model,Title="",SubTitle="",Caption="")
{
  
  library(ggplot2)
  
  MeanDecreaseGini <- importance(Model)
  MeanDecreaseGini <- as.data.frame(MeanDecreaseGini)
  MeanDecreaseGini$Variable <- rownames(MeanDecreaseGini)
  
  ImpPlot <- ggplot(data = MeanDecreaseGini, aes(Variable, IncNodePurity)) +
    geom_bar(stat = "identity", position = "dodge",colour="red",alpha=0.8,fill="red") +
    labs(caption = Caption) +
    theme_AI() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ggtitle(Title) 
  print(ImpPlot)
}


###############################################################################
#
#   Data Analysis Code
#
#   Use this function to load your data and draw charts of your data 
#
###############################################################################

MLDataAnalysis <- function(MLParameterList,DataLoadParameters)
{
  
  # Load data
  DataFrame <- DataLoadAndFormat(Backtest=MLParameterList$BackTest,
                                 Debug=MLParameterList$Debug,
                                 ConvertToFactors=MLParameterList$ConvertToFactors,
                                 DataLoadParameters)
  
  if (nrow(DataFrame)>0) 
  {
    # Fix the first letter of the columns (Makes x a Big X) plus change the prediction variable
    colnames(DataFrame) <- CapitaliseFirstLetter(colnames(DataFrame))
    MLParameterList$PredictionVariable <- CapitaliseFirstLetter(MLParameterList$PredictionVariable)
    
    # Check data formats before pre-processing
    #DataAnalysis(DataFrame,
    #             PredictionVariable  = MLParameterList$PredictionVariable,
    #             Title               = MLParameterList$ProjectTitle,
    #             PrintExamples       = MLParameterList$PrintExamplesinAnalysis,
    #             DrawCharts          = MLParameterList$DrawChartsinAnalysis,
    #             DrawHistograms      = MLParameterList$DrawHistograms,
    #             DrawVersusPlots     = MLParameterList$DrawVersusPlots)
    
    # Pre-Process
    ListOfDataFrames <- PreProcess(DataFrame,
                                   Columns = MLParameterList$ColumnsToSelectForTraining,
                                   ColumnNames = MLParameterList$DisplayColumnNames,
                                   Backtest = MLParameterList$BackTest,
                                   Debug = MLParameterList$Debug,
                                   PercentageToSplit = MLParameterList$SplitPercent,
                                   UseSampleMethod = MLParameterList$SamplingMethod,
                                   OneHotEncodeFactors=MLParameterList$OneHotEncodeFactors,
                                   Rescale=MLParameterList$Rescale,
                                   MaxValues=MLParameterList$Maximums,
                                   MinValues=MLParameterList$Minimums,
                                   AutoScalingOn = MLParameterList$AutoScaling)
    
    # Check data formats after pre-processing
    DataAnalysis(ListOfDataFrames[[1]],
                 PredictionVariable  = MLParameterList$PredictionVariable,
                 Title               = MLParameterList$ProjectTitle,
                 PrintExamples       = MLParameterList$PrintExamplesinAnalysis,
                 DrawCharts          = MLParameterList$DrawChartsinAnalysis,
                 DrawHistograms      = MLParameterList$DrawHistograms,
                 DrawVersusPlots     = MLParameterList$DrawVersusPlots,
                 Debug               = MLParameterList$Debug,
                 DrawMissingValues   = MLParameterList$DrawMissingValues)
    
    # Display max and mins from training set
    if (MLParameterList$Debug == TRUE)
    {
      print("Max and min values from training set")
      print(DataFrameMaxAndMins(ListOfDataFrames[[1]]))
    }
  }
}

###############################################################################
#
#   Training Code
#
###############################################################################

MLTraining <- function(MLParameterList,DataLoadParameters)
{
  
  # Load data
  DataFrame <- DataLoadAndFormat(Backtest=MLParameterList$BackTest,
                                 Debug=MLParameterList$Debug,
                                 ConvertToFactors=MLParameterList$ConvertToFactors,
                                 DataLoadParameters)
  
  if (nrow(DataFrame)>0) 
  {
    # Fix the first letter of the columns (Makes x a Big X) plus change the prediction variable
    colnames(DataFrame) <- CapitaliseFirstLetter(colnames(DataFrame))
    MLParameterList$PredictionVariable <- CapitaliseFirstLetter(MLParameterList$PredictionVariable)
    
    # Pre-Process
    ListOfDataFrames <- PreProcess(DataFrame,
                                   Columns = MLParameterList$ColumnsToSelectForTraining,
                                   ColumnNames = MLParameterList$DisplayColumnNames,
                                   Backtest = MLParameterList$BackTest,
                                   Debug = MLParameterList$Debug,
                                   PercentageToSplit = MLParameterList$SplitPercent,
                                   UseSampleMethod = MLParameterList$SamplingMethod,
                                   OneHotEncodeFactors=MLParameterList$OneHotEncodeFactors,
                                   Rescale=MLParameterList$Rescale,
                                   MaxValues=MLParameterList$Maximums,
                                   MinValues=MLParameterList$Minimums,
                                   AutoScalingOn = MLParameterList$AutoScaling)
    
    if (MLParameterList$AutoScaling == TRUE)
    {
      MLParameterList$Maximums <- ListOfDataFrames[[3]]
      MLParameterList$Minimums <- ListOfDataFrames[[4]]
      MLParameterList$ColumnsToSelectForTraining <- ListOfDataFrames[[5]]
      MLParameterList$VariableNames <- ListOfDataFrames[[6]]
      MLParameterList$DisplayColumnNames <- ListOfDataFrames[[7]]
    }

    ###############
    #
    # SpecialModel
    #
    ###############
    
    
    if (MLParameterList$RegressionModel == "SpecialModel")
    {
      
      if (MLParameterList$Debug == TRUE) {print("Training with SpecialModel")}
      
      # Training
      Model <-     TrainingModelSpecialModel(ListOfDataFrames[[1]],
                                   ColumnNames            = MLParameterList$VariableNames,
                                   PredictVariable        = MLParameterList$PredictionVariable,
                                   Backtest               = MLParameterList$BackTest,
                                   Debug                  = MLParameterList$Debug,
                                   SaveModel              = MLParameterList$SaveModelToFile,
                                   PlotImportance         = MLParameterList$DrawImportanceCharts,
                                   FileName               = MLParameterList$FileNameOfModel)
      
      
      # Predict from training
      TrainingPredictions <- PredictSpecialModel(ListOfDataFrames[[1]],
                                       ColumnNames            = MLParameterList$VariableNames,
                                       Model                  = Model,
                                       Backtest               = MLParameterList$BackTest,
                                       Debug                  = MLParameterList$Debug,
                                       LoadModel              = MLParameterList$SaveModelToFile,
                                       FileName               = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      # Predict testing set
      TestingPredictions <- PredictSpecialModel(ListOfDataFrames[[2]],
                                      ColumnNames            = MLParameterList$VariableNames,
                                      Model                  = Model,
                                      Backtest               = MLParameterList$BackTest,
                                      Debug                  = MLParameterList$Debug,
                                      LoadModel              = MLParameterList$SaveModelToFile,
                                      FileName               = MLParameterList$FileNameOfModel,
                                      PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
      
    }
    
    ###############
    #
    # GLM
    #
    ###############
    
    
    if (MLParameterList$RegressionModel == "GLM")
    {
      
      if (MLParameterList$Debug == TRUE) {print("Training with GLM")}
      
      # Training
      Model <-     TrainingModelGLM(ListOfDataFrames[[1]],
                                   ColumnNames            = MLParameterList$VariableNames,
                                   PredictVariable        = MLParameterList$PredictionVariable,
                                   Link                   = MLParameterList$Link,
                                   Backtest               = MLParameterList$BackTest,
                                   Debug                  = MLParameterList$Debug,
                                   SaveModel              = MLParameterList$SaveModelToFile,
                                   PlotImportance         = MLParameterList$DrawImportanceCharts,
                                   FileName               = MLParameterList$FileNameOfModel)
      
      
      # Predict from training
      TrainingPredictions <- PredictGLM(ListOfDataFrames[[1]],
                                       ColumnNames            = MLParameterList$VariableNames,
                                       Model                  = Model,
                                       Backtest               = MLParameterList$BackTest,
                                       Debug                  = MLParameterList$Debug,
                                       LoadModel              = MLParameterList$SaveModelToFile,
                                       FileName               = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      # Predict testing set
      TestingPredictions <- PredictGLM(ListOfDataFrames[[2]],
                                      ColumnNames            = MLParameterList$VariableNames,
                                      Model                  = Model,
                                      Backtest               = MLParameterList$BackTest,
                                      Debug                  = MLParameterList$Debug,
                                      LoadModel              = MLParameterList$SaveModelToFile,
                                      FileName               = MLParameterList$FileNameOfModel,
                                      PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
      
    }
    
    ###############
    
    if (MLParameterList$RegressionModel == "SVM")
    {
      if (MLParameterList$Debug == TRUE) {print("Training with Support Vector Machine")}
      
      # Training
      Model <-     TrainingModelSVM(ListOfDataFrames[[1]],
                                    ColumnNames     = MLParameterList$VariableNames,
                                    PredictVariable = MLParameterList$PredictionVariable,
                                    Backtest        = MLParameterList$BackTest,
                                    Debug           = MLParameterList$Debug,
                                    SaveModel       = MLParameterList$SaveModelToFile,
                                    PlotImportance  = MLParameterList$DrawImportanceCharts,
                                    FileName        = MLParameterList$FileNameOfModel)
      
      # Predict from training
      TrainingPredictions <- PredictSVM(ListOfDataFrames[[1]],
                                        ColumnNames = MLParameterList$VariableNames,
                                        Model       = Model,
                                        Backtest    = MLParameterList$BackTest,
                                        Debug       = MLParameterList$Debug,
                                        LoadModel   = MLParameterList$SaveModelToFile,
                                        FileName    = MLParameterList$FileNameOfModel,
                                        PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      
      # Predict testing set
      TestingPredictions <- PredictSVM(ListOfDataFrames[[2]],
                                       ColumnNames = MLParameterList$VariableNames,
                                       Model       = Model,
                                       Backtest    = MLParameterList$BackTest,
                                       Debug       = MLParameterList$Debug,
                                       LoadModel   = MLParameterList$SaveModelToFile,
                                       FileName    = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
      
    }
    
    if (MLParameterList$RegressionModel == "RF")
    {
      
      if (MLParameterList$Debug == TRUE) {print("Training with Random Forrest - Original version")}
      
      # Training
      Model <-     TrainingModelRF(ListOfDataFrames[[1]],
                                   ColumnNames            = MLParameterList$VariableNames,
                                   PredictVariable        = MLParameterList$PredictionVariable,
                                   NTrees                 = MLParameterList$NumberOfTrees,
                                   Backtest               = MLParameterList$BackTest,
                                   Debug                  = MLParameterList$Debug,
                                   SaveModel              = MLParameterList$SaveModelToFile,
                                   PlotImportance         = MLParameterList$DrawImportanceCharts,
                                   FileName               = MLParameterList$FileNameOfModel)
      
      
      # Predict from training
      TrainingPredictions <- PredictRF(ListOfDataFrames[[1]],
                                       ColumnNames            = MLParameterList$VariableNames,
                                       Model                  = Model,
                                       Backtest               = MLParameterList$BackTest,
                                       Debug                  = MLParameterList$Debug,
                                       LoadModel              = MLParameterList$SaveModelToFile,
                                       FileName               = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      # Predict testing set
      TestingPredictions <- PredictRF(ListOfDataFrames[[2]],
                                      ColumnNames            = MLParameterList$VariableNames,
                                      Model                  = Model,
                                      Backtest               = MLParameterList$BackTest,
                                      Debug                  = MLParameterList$Debug,
                                      LoadModel              = MLParameterList$SaveModelToFile,
                                      FileName               = MLParameterList$FileNameOfModel,
                                      PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
      
    }
    
    
    if (MLParameterList$RegressionModel == "RFRLT")
    {
      if (MLParameterList$Debug == TRUE) {print("Training with Random Forrest - RLT version")}
      
      # Training
      Model <-     TrainingModelRFRLT(ListOfDataFrames[[1]],
                                      ColumnNames       = MLParameterList$VariableNames,
                                      PredictVariable   = MLParameterList$PredictionVariable,
                                      NTrees            = MLParameterList$NumberOfTrees,
                                      SaveModel         = MLParameterList$SaveModelToFile,
                                      PlotImportance    = MLParameterList$DrawImportanceCharts,
                                      RegType           = MLParameterList$RegressionType,
                                      FileName          = MLParameterList$FileNameOfModel,
                                      Debug             = MLParameterList$Debug)
      
      
      # Predict from training
      TrainingPredictions <- PredictRFRLT(ListOfDataFrames[[1]],
                                          ColumnNames       = MLParameterList$VariableNames,
                                          Model             = Model,
                                          Backtest          = MLParameterList$BackTest,
                                          Debug             = MLParameterList$Debug,
                                          LoadModel         = MLParameterList$SaveModelToFile,
                                          FileName          = MLParameterList$FileNameOfModel,
                                          PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      # Predict testing set
      TestingPredictions <- PredictRFRLT(ListOfDataFrames[[2]],
                                         ColumnNames       = MLParameterList$VariableNames,
                                         Model             = Model,
                                         Backtest          = MLParameterList$BackTest,
                                         Debug             = MLParameterList$Debug,
                                         LoadModel         = MLParameterList$SaveModelToFile,
                                         FileName          = MLParameterList$FileNameOfModel,
                                         PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
      
    }
    
    if (MLParameterList$RegressionModel == "NN")
    {
      
      if (MLParameterList$Debug == TRUE) {print("Training with Neural Network version")}
      
      # Training
      Model <-     TrainingModelNN(ListOfDataFrames[[1]],
                                   ColumnNames    = MLParameterList$ColumnsToSelectForTraining,
                                   PredictVariable= MLParameterList$PredictionVariable,
                                   HiddenNodes    = MLParameterList$HiddenLayersStructure,
                                   Backtest       = MLParameterList$BackTest,
                                   Debug          = MLParameterList$Debug,
                                   SaveModel      = MLParameterList$SaveModelToFile,
                                   FileName        = MLParameterList$FileNameOfModel,
                                   Iterations      = MLParameterList$Iterations)
      
      # Predict training set
      TrainingPredictions <- PredictNN(DataFrame=ListOfDataFrames[[1]],
                                       PredictVariable =  MLParameterList$PredictionVariable,
                                       ColumnNames     =  MLParameterList$DisplayColumnNames,
                                       Model,
                                       Backtest        =  MLParameterList$BackTest,
                                       Debug           =  MLParameterList$Debug,
                                       LoadModel       =  MLParameterList$SaveModelToFile,
                                       FileName        =  MLParameterList$FileNameOfModel)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      # Predict training set
      TestingPredictions <- PredictNN(DataFrame=ListOfDataFrames[[2]],
                                      PredictVariable =  MLParameterList$PredictionVariable,
                                      ColumnNames     =  MLParameterList$DisplayColumnNames,
                                      Model,
                                      Backtest        =  MLParameterList$BackTest,
                                      Debug           =  MLParameterList$Debug,
                                      LoadModel       =  MLParameterList$SaveModelToFile,
                                      FileName        =  MLParameterList$FileNameOfModel)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
    }
    
    # Use KNN model to train and predict
    if (MLParameterList$RegressionModel == "KNN")
    {
      if (MLParameterList$Debug == TRUE) {print("Training with K nearest neighbour")}
      
      # Training
      Model <-     TrainingModelKNN(ListOfDataFrames[[1]],
                                    ColumnNames       = MLParameterList$VariableNames,
                                    PredictVariable   = MLParameterList$PredictionVariable,
                                    Debug             = MLParameterList$Debug,
                                    K                 = MLParameterList$K,
                                    SaveModel         = MLParameterList$SaveModelToFile,
                                    PlotImportance    = MLParameterList$DrawImportanceCharts,
                                    RegType           = MLParameterList$RegressionType,
                                    FileName          = MLParameterList$FileNameOfModel)
      
      
      # Predict from training
      TrainingPredictions <- PredictKNN(ListOfDataFrames[[1]],
                                        ColumnNames       = MLParameterList$VariableNames,
                                        Model             = Model,
                                        Backtest          = MLParameterList$BackTest,
                                        Debug             = MLParameterList$Debug,
                                        LoadModel         = MLParameterList$SaveModelToFile,
                                        FileName          = MLParameterList$FileNameOfModel,
                                        PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      # Predict testing set
      TestingPredictions <- PredictKNN(ListOfDataFrames[[2]],
                                       ColumnNames       = MLParameterList$VariableNames,
                                       Model             = Model,
                                       Backtest          = MLParameterList$BackTest,
                                       Debug             = MLParameterList$Debug,
                                       LoadModel         = MLParameterList$SaveModelToFile,
                                       FileName          = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
      
    }
    
    # Use XGBoost model to train and predict
    if (MLParameterList$RegressionModel == "XGB")
    {
      if (MLParameterList$Debug == TRUE) {print("Training with XGBoost nearest neighbour")}
      
      # Training
      Model <-     TrainingModelXGBoost(ListOfDataFrames[[1]],
                                        ColumnNames       = MLParameterList$VariableNames,
                                        PredictVariable   = MLParameterList$PredictionVariable,
                                        SaveModel         = MLParameterList$SaveModelToFile,
                                        PlotImportance    = MLParameterList$DrawImportanceCharts,
                                        RegType           = MLParameterList$RegressionType,
                                        FileName          = MLParameterList$FileNameOfModel,
                                        Debug             = MLParameterList$Debug)
      
      
      # Predict from training
      TrainingPredictions <- PredictXGBoost(ListOfDataFrames[[1]],
                                            ColumnNames       = MLParameterList$VariableNames,
                                            Model             = Model,
                                            Backtest          = MLParameterList$BackTest,
                                            Debug             = MLParameterList$Debug,
                                            LoadModel         = MLParameterList$SaveModelToFile,
                                            FileName          = MLParameterList$FileNameOfModel,
                                            PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      # Predict testing set
      TestingPredictions <- PredictXGBoost(ListOfDataFrames[[2]],
                                           ColumnNames       = MLParameterList$VariableNames,
                                           Model             = Model,
                                           Backtest          = MLParameterList$BackTest,
                                           Debug             = MLParameterList$Debug,
                                           LoadModel         = MLParameterList$SaveModelToFile,
                                           FileName          = MLParameterList$FileNameOfModel,
                                           PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
    }
    
    # Use KERAS model to train and predict
    if (MLParameterList$RegressionModel == "KERAS")
    {
      if (MLParameterList$Debug == TRUE) {print("Training with KERAS deep neural networks")}
      
      Model <- TrainingModelKeras(DataFrame       = ListOfDataFrames[[1]],
                                  ColumnNames     = MLParameterList$VariableNames,
                                  PredictVariable = MLParameterList$PredictionVariable,
                                  Backtest        = MLParameterList$BackTest,
                                  Debug           = MLParameterList$Debug,
                                  SaveModel       = MLParameterList$SaveModelToFile,
                                  FileName        = MLParameterList$FileNameOfModel,
                                  Type            = MLParameterList$RegressionType,
                                  Epochs          = MLParameterList$Epochs,
                                  BatchSize       = MLParameterList$BatchSize,
                                  ValidationSplit = MLParameterList$ValidationSplit)
      
      # Predict from training
      TrainingPredictions <- PredictKeras(DataFrame=ListOfDataFrames[[1]],
                                          ColumnNames     = MLParameterList$VariableNames,
                                          Model           = Model,
                                          Backtest        = MLParameterList$BackTest,
                                          Debug           = MLParameterList$Debug,
                                          LoadModel       = MLParameterList$SaveModelToFile,
                                          FileName        = MLParameterList$FileNameOfModel,
                                          PredictVariable = MLParameterList$PredictionVariable,
                                          Type=MLParameterList$RegressionType)
      
      # Do results processing
      TrainingResultsDataFrame <- PostProcess(TrainingPredictions,
                                              PredictVariable     = MLParameterList$PredictionVariable,
                                              Backtest            = MLParameterList$BackTest,
                                              Debug               = MLParameterList$Debug,
                                              TestingSet          = FALSE,
                                              RegressionModel     = MLParameterList$RegressionModel,
                                              Variable            = MLParameterList$PredictionVariable,
                                              RegType             = MLParameterList$RegressionType,
                                              DrawCharts          = MLParameterList$DrawChartsOfResults,
                                              Rescale=MLParameterList$Rescale,
                                              MaxValues=MLParameterList$Maximums,
                                              MinValues=MLParameterList$Minimums,
                                              ColumnNames=MLParameterList$DisplayColumnNames)
      
      # Predict from training
      TestingPredictions <- PredictKeras(DataFrame=ListOfDataFrames[[2]],
                                         ColumnNames     = MLParameterList$VariableNames,
                                         Model           = Model,
                                         Backtest        = MLParameterList$BackTest,
                                         Debug           = MLParameterList$Debug,
                                         LoadModel       = MLParameterList$SaveModelToFile,
                                         FileName        = MLParameterList$FileNameOfModel,
                                         PredictVariable = MLParameterList$PredictionVariable,
                                         Type            = MLParameterList$RegressionType)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
    }
  } else {
    
    if (MLParameterList$Debug == TRUE) {print("No data found")}
    
  }
  
  
  return(Results)
  
}


###############################################################################
#
#   Prediction Function
#
###############################################################################

MLPrediction <- function(MLParameterList,DataLoadParameters)
{
  
  # Load data
  DataFrame <- DataLoadAndFormat(Backtest   =  MLParameterList$BackTest,
                                 Debug      =  MLParameterList$Debug,
                                 ConvertToFactors = MLParameterList$ConvertToFactors,
                                 DataLoadParameters = DataLoadParameters)
  
  if (nrow(DataFrame)>0) 
  {
    
    # Fix the first letter of the columns (Makes x a Big X) plus change the prediction variable
    colnames(DataFrame) <- CapitaliseFirstLetter(colnames(DataFrame))
    MLParameterList$PredictionVariable <- CapitaliseFirstLetter(MLParameterList$PredictionVariable)
    
    # Pre-Process
    ListOfDataFrames <- PreProcess(DataFrame,
                                   Columns = MLParameterList$ColumnsToSelectForTraining,
                                   ColumnNames = MLParameterList$DisplayColumnNames,
                                   Backtest = MLParameterList$BackTest,
                                   Debug = MLParameterList$Debug,
                                   PercentageToSplit = MLParameterList$SplitPercent,
                                   UseSampleMethod = MLParameterList$SamplingMethod,
                                   OneHotEncodeFactors=MLParameterList$OneHotEncodeFactors,
                                   Rescale=MLParameterList$Rescale,
                                   MaxValues=MLParameterList$Maximums,
                                   MinValues=MLParameterList$Minimums,
                                   AutoScalingOn = FALSE)  # Cannot use auto scaling when making predictions
    
    
    ###################
    #
    # SpecialModel
    #
    ###################
    
    if (MLParameterList$RegressionModel == "SpecialModel")
    {
      if (MLParameterList$Debug == TRUE) {print("Predicting with a SpecialModel")}
      
      # Predict testing set
      TestingPredictions <- PredictSpecialModel(ListOfDataFrames[[2]],
                                       ColumnNames = MLParameterList$VariableNames,
                                       Model       = Model,
                                       Backtest    = MLParameterList$BackTest,
                                       Debug       = MLParameterList$Debug,
                                       LoadModel   = MLParameterList$SaveModelToFile,
                                       FileName    = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    ###################
    #
    # GLM
    #
    ###################
    
    if (MLParameterList$RegressionModel == "GLM")
    {
      if (MLParameterList$Debug == TRUE) {print("Predicting with a Support Vector Machine")}
      
      # Predict testing set
      TestingPredictions <- PredictGLM(ListOfDataFrames[[2]],
                                       ColumnNames = MLParameterList$VariableNames,
                                       Model       = Model,
                                       Backtest    = MLParameterList$BackTest,
                                       Debug       = MLParameterList$Debug,
                                       LoadModel   = MLParameterList$SaveModelToFile,
                                       FileName    = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    
    ###################
    #
    # SVM
    #
    ###################
    
    if (MLParameterList$RegressionModel == "SVM")
    {
      if (MLParameterList$Debug == TRUE) {print("Predicting with a Support Vector Machine")}
      
      # Predict testing set
      TestingPredictions <- PredictSVM(ListOfDataFrames[[2]],
                                       ColumnNames = MLParameterList$VariableNames,
                                       Model       = Model,
                                       Backtest    = MLParameterList$BackTest,
                                       Debug       = MLParameterList$Debug,
                                       LoadModel   = MLParameterList$SaveModelToFile,
                                       FileName    = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    if (MLParameterList$RegressionModel == "RF")
    {
      
      if (MLParameterList$Debug == TRUE) {print("Prediction with Random Forrest - Original version")}
      
      # Predict testing set
      TestingPredictions <- PredictRF(ListOfDataFrames[[2]],
                                      ColumnNames            = MLParameterList$VariableNames,
                                      Model                  = Model,
                                      Backtest               = FALSE,
                                      Debug                  = FALSE,
                                      LoadModel              = TRUE,
                                      FileName               = MLParameterList$FileNameOfModel)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = FALSE,
                                             Debug               = FALSE,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
    }
    
    if (MLParameterList$RegressionModel == "RFRLT")
    {
      if (MLParameterList$Debug == TRUE) {print("Predicting with Random Forrest - RLT version")}
      
      
      # Predict testing set
      TestingPredictions <- PredictRFRLT(ListOfDataFrames[[2]],
                                         ColumnNames       = MLParameterList$VariableNames,
                                         Model             = Model,
                                         Backtest          = MLParameterList$BackTest,
                                         Debug             = MLParameterList$Debug,
                                         LoadModel         = MLParameterList$SaveModelToFile,
                                         FileName          = MLParameterList$FileNameOfModel,
                                         PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    # Use XGBoost model to train and predict
    if (MLParameterList$RegressionModel == "XGB")
    {
      if (MLParameterList$Debug == TRUE) {print("Predicting with XGBoost")}
      
      
      # Predict testing set
      TestingPredictions <- PredictXGBoost(ListOfDataFrames[[2]],
                                           ColumnNames       = MLParameterList$VariableNames,
                                           Model             = Model,
                                           Backtest          = MLParameterList$BackTest,
                                           Debug             = MLParameterList$Debug,
                                           LoadModel         = MLParameterList$SaveModelToFile,
                                           FileName          = MLParameterList$FileNameOfModel,
                                           PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
    }
    
    # Use KNN model to train and predict
    if (MLParameterList$RegressionModel == "KNN")
    {
      if (MLParameterList$Debug == TRUE) {print("Training with K nearest neighbour")}
      
      # Predict testing set
      TestingPredictions <- PredictKNN(ListOfDataFrames[[2]],
                                       ColumnNames       = MLParameterList$VariableNames,
                                       Model             = Model,
                                       Backtest          = MLParameterList$BackTest,
                                       Debug             = MLParameterList$Debug,
                                       LoadModel         = MLParameterList$SaveModelToFile,
                                       FileName          = MLParameterList$FileNameOfModel,
                                       PredictVariable = MLParameterList$PredictionVariable)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    if (MLParameterList$RegressionModel == "NN")
    {
      
      if (MLParameterList$Debug == TRUE) {print("Training with Neural Network version")}
      
      # Predict training set
      TestingPredictions <- PredictNN(DataFrame=ListOfDataFrames[[2]],
                                      PredictVariable =  MLParameterList$PredictionVariable,
                                      ColumnNames     =  MLParameterList$DisplayColumnNames,
                                      Model,
                                      Backtest        =  MLParameterList$BackTest,
                                      Debug           =  MLParameterList$Debug,
                                      LoadModel       =  MLParameterList$SaveModelToFile,
                                      FileName        =  MLParameterList$FileNameOfModel)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
      
    }
    
    
    if (MLParameterList$RegressionModel == "KERAS")
    {
      
      if (MLParameterList$Debug == TRUE) {print("Training with KERAS")}
      
      # Predict from training
      TestingPredictions <- PredictKeras(DataFrame=ListOfDataFrames[[2]],
                                         ColumnNames     = MLParameterList$VariableNames,
                                         Model           = Model,
                                         Backtest        = MLParameterList$BackTest,
                                         Debug           = MLParameterList$Debug,
                                         LoadModel       = MLParameterList$SaveModelToFile,
                                         FileName        = MLParameterList$FileNameOfModel,
                                         PredictVariable = MLParameterList$PredictionVariable,
                                         Type            = MLParameterList$RegressionType)
      
      # Do results processing
      TestingResultsDataFrame <- PostProcess(TestingPredictions,
                                             PredictVariable     = MLParameterList$PredictionVariable,
                                             Backtest            = MLParameterList$BackTest,
                                             Debug               = MLParameterList$Debug,
                                             TestingSet          = TRUE,
                                             RegressionModel     = MLParameterList$RegressionModel,
                                             Variable            = MLParameterList$PredictionVariable,
                                             RegType             = MLParameterList$RegressionType,
                                             DrawCharts          = MLParameterList$DrawChartsOfResults,
                                             Rescale=MLParameterList$Rescale,
                                             MaxValues=MLParameterList$Maximums,
                                             MinValues=MLParameterList$Minimums,
                                             ColumnNames=MLParameterList$DisplayColumnNames)
      
    }
  } else {
    if (MLParameterList$Debug == TRUE) {print("No data found")}
  }
  
  Results <- ProcessPredictions(TrainingResultsDataFrame,TestingResultsDataFrame,DataFrame,DataLoadParameters)
  
  
  return(Results)
  
}



# Call these two functions when script is sourced
#DataLoadParameters <- SetDataLoadParameters(Debug=TRUE)
#MLParameterList    <- SetParameters(Debug=TRUE)

# Data analysis function
#MLDataAnalysis(MLParameterList,DataLoadParameters)


# Call the training function
#MLParameterList$RegressionModel           <- "XGB" 
#Results <- MLTraining(MLParameterList,DataLoadParameters)
#print(head(Results))
#plot(Results$Actual)
#plot(Results$Prediction)


ModelTest <- function()
{
  # Auto ML - Which model gives best predictions
  ModelsToTest <- c("RF","NN","KNN","RFRLT","SVM","KERAS","XGB")
  
  ModelsToTest <- rep("XGB",10)
  
  ListOfResults <- data.frame(Model = "NA",RMSE = 0)
  for (Model in ModelsToTest)
  {
    MLParameterList$RegressionModel           <- Model 
    Results <- MLTraining(MLParameterList,DataLoadParameters)
    
    # Plot the shape
    Results$X <- seq(1,nrow(Results))
    ResultsPlot <- ggplot(Results,aes(x=X,y=Prediction)) +
      geom_point(aes(x=X,y=Prediction),
                 colour="Red",
                 fill="Darkred",
                 size=1) +
      geom_point(aes(x=X,y=Actual),
                 colour="DarkGreen",
                 fill="DarkGreen",
                 size=1) +
      xlab(paste("X")) +
      ylab(paste("Prediction")) +
      theme_AI() +
      ggtitle(paste("Results",Model))
    print(ResultsPlot)
    
    # Calculate RMSE
    RMSE          <- sqrt(mean(Results$Error * Results$Error))
    ListOfResults <- rbind(ListOfResults,data.frame(Model=Model,RMSE=RMSE))
    
  }
  ListOfResults <- ListOfResults[-1,] # Remove the first one
  
  # Round Results
  ListOfResults$RMSE <- round(ListOfResults$RMSE,3)
  
  # Now arrange
  library(plyr)
  ListOfResults <- arrange(ListOfResults,RMSE)
  print(ListOfResults)
  print(paste("Mean result",mean(ListOfResults$RMSE)))
  print(paste("SD result",sd(ListOfResults$RMSE)))
  hist(ListOfResults$RMSE)
  
}

#ModelTest()
