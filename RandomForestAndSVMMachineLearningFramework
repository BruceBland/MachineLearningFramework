###########################################################
#
# Machine Learning Framework
#
# For Random Forrests and SVM models only
#
###########################################################
#
# Designed to ensure that data is correctly partioned, and processed 
#
# By B. G. Bland (Fidessa RAID Team)
#
set.seed(500) # Forces same random number to be produced

# Example Framework code
rm(list=ls())

library(ggplot2)

# This example uses the mtcars dataset which is provided in base R.
# Use the following fields to change the behaviour

#[, 1]	mpg	  -   Miles/(US) gallon
#[, 2]	cyl	  -   Number of cylinders
#[, 3]	disp	-   Displacement (cu.in.)
#[, 4]	hp	  -   Gross horsepower
#[, 5]	drat	-   Rear axle ratio
#[, 6]	wt	  -   Weight (1000 lbs)
#[, 7]	qsec	-   1/4 mile time
#[, 8]	vs	  -   Engine (0 = V-shaped, 1 = straight)
#[, 9]	am	  -   Transmission (0 = automatic, 1 = manual)
#[,10]	gear	-   Number of forward gears
#[,11]	carb	-   Number of carburetors

# Edit these variables to control the columns to fit 
ColumnsToSelectForTraining <- c("carb","cyl","disp","hp","gear","wt") # Reduce data set from original
DisplayColumnNames <- c("Carbs","Cyl","Displace","HP","Gears","Weight")    # Rename the columns
                                 
# Prediction variable
PredictionVariable <- "Cyl"                                          # y^ the prediction variable
VariableNames <- setdiff(DisplayColumnNames,PredictionVariable)

RegressionModel <- "SVM"   # Can be SVM , RF or RFRLT
RegressionType <- "regression" #  regression, classification
NumberOfTrees <- 10
SplitPercent <- 30/100

#####################################################################################
#
# Functions - Edit the Data Load and Format Function to ingest the data
#
#####################################################################################

# Function to load a check data 
DataLoadAndFormat <- function(Backtest=TRUE,Debug=TRUE)
{
  if (Debug==TRUE) {print("Loading data")}
  
  # Use example iris data set
  DataFrame <- mtcars
  
  return(DataFrame)
}

## Quick summary of data we are using to compute the column type and number of levels
DataAnalysis <- function(DataFrame)
{
  print("  Unique Values in DataFrame")
  Cols <- colnames(DataFrame)
  for (col in Cols)
  {
    # Select the column number
    ColNo <- which(Cols == col)
    print(paste("    Items from column",col,"No types =",length(unique(DataFrame[,ColNo]))))
    print(paste("    Class for column",col,"=",class(DataFrame[,ColNo]),"with",length(levels(DataFrame[,ColNo])),"levels"))
    
    # Now print the top 50 unique values in the column
    for (i in head(unique(DataFrame[,ColNo]),50)){print(paste("        ",col,"=",i))}
    
  }
  print("   Summary of data frame")
  Sm <- summary(DataFrame)
  print(Sm)
  
}

# Split function
SplitData <- function(DataFrame,PercentToSplit)
{
  # Will add index column
  DataFrame$x <- seq(1,nrow(DataFrame))
  
  ## Number of rows to sample
  smp_size <- floor(PercentToSplit * nrow(DataFrame))
  
  # Create sampling index
  train_ind <- sample(DataFrame$x, size = smp_size)
  
  # Now split te data into training and test
  train <- DataFrame[train_ind, ]
  test <- DataFrame[-train_ind, ]
  
  # Now remove the x variable
  train$x <- NULL
  test$x <- NULL
  
  # Return list of data frames
  ReturnList <- list(train,test)
  
  return(ReturnList)
}

# Function to pre-process the data
PreProcess <- function(DataFrame,Columns,ColumnNames,Backtest=TRUE,Debug=TRUE,PercentageToSplit=0)
{
  if (Debug==TRUE) {print("PreProcessing data")}
  
  # Generic code
  DataFrame <- DataFrame[,Columns]
  colnames(DataFrame) <- ColumnNames
  
  # Split data
  ListOfDataFrames <- SplitData(DataFrame,PercentToSplit=PercentageToSplit)
  
  return(ListOfDataFrames)
}

TrainingModelRF <- function(DataFrame,ColumnNames,PredictVariable="S",NTrees=5,
                            Backtest=TRUE,Debug=TRUE,SaveModel=FALSE,PlotImportance=TRUE)
{
  if (Debug==TRUE) {print("Training on data using RF Model")}
  
  library(randomForest)
  
  PredictVariable <- DataFrame[,PredictVariable]
  
  VariableColumns <- DataFrame[,ColumnNames]
  
  DataFrame <- cbind(VariableColumns,PredictVariable)
  
  #Print the fitting parameters
  print(paste("ntrees = ",NTrees))
  
  # Train
  Model = randomForest(PredictVariable ~ . ,
                       data = DataFrame,
                       keep.forest=TRUE,
                       importance=TRUE,
                       ntrees = NTrees)
  
  # Save model if required
  if (SaveModel == TRUE) {saveRDS(Model, "RandomForest.rds")}
  
  # Plot importance
  #if (PlotImportance == TRUE) {ImportancePlot(Model,"Example Importance Plot","Random Forest Model")}
  
  return(Model)
  
}

PredictRF <- function(DataFrame,ColumnNames,Model,
                      Backtest=TRUE,Debug=TRUE)
{
  if (Debug==TRUE) {print("Predicting from model and data using RF Model")}
  
  VariableColumns <- DataFrame[,ColumnNames]
  
  DataFrame$Prediction <- predict(Model,VariableColumns)
  
  return(DataFrame)
}

TrainingModelRFRLT <- function(DataFrame,ColumnNames,PredictVariable="",NTrees=10,
                               Backtest=TRUE,Debug=TRUE,SaveModel=FALSE,PlotImportance=TRUE,RegType="")
{
  if (Debug==TRUE) {print("Training on data using RFRLT model")}
  
  library(RLT)
  
  # Select Cols required
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,ColumnNames]
  
  # Run model
  Model = RLT(VariableColumns, PredictVariable,
              model = RegType, #  regression, classification or survival 
              use.cores = 7,
              ntrees = NTrees,
              importance = TRUE, 
        #      reinforcement = TRUE,
              combsplit = 3,
              embed.ntrees = 50)
  
  # Save model if required
  if (SaveModel == TRUE) {saveRDS(Model, "RandomForestRLT.rds")}
  
  # Plot importance
  if (PlotImportance == TRUE) {barplot(Model$VarImp)}
  
  return(Model)
  
}

PredictRFRLT <- function(DataFrame,ColumnNames,Model,
                         Backtest=TRUE,Debug=TRUE)
{
  if (Debug==TRUE) {print("Predicting from RF RLT model and data")}
  
  VariableColumns <- DataFrame[,ColumnNames]
  
  PredictionList <- predict(Model,VariableColumns)
  
  DataFrame$Prediction <- PredictionList[[2]]   # Select only the predictions
  
  return(DataFrame)
  
}

TrainingModelSVM <- function(DataFrame,ColumnNames,PredictVariable="",NTrees=10,
                             Backtest=TRUE,Debug=TRUE,SaveModel=FALSE,PlotImportance=TRUE)
{
  if (Debug==TRUE) {print("Training on data using Support Vector Machine")}
  
  library(e1071)
  
  # Select Cols required
  PredictVariable <- DataFrame[,PredictVariable]
  VariableColumns <- DataFrame[,ColumnNames]
  
  Model <- svm(VariableColumns, PredictVariable)
  
  if (PlotImportance==TRUE)
  {
    print(summary(Model))
  }
  
  return(Model)
  
}

PredictSVM <- function(DataFrame,ColumnNames,Model,
                       Backtest=TRUE,Debug=TRUE)
{
  if (Debug==TRUE) {print("Predicting from data using Support Vector Machine model")}
  
  VariableColumns <- DataFrame[,ColumnNames]
  
  PredictionList <- predict(Model,VariableColumns)
  
  DataFrame$Prediction <- PredictionList   
  
  return(DataFrame)
  
}

# Handles the testing of the accuracy of fit extra
PostProcess <- function(DataFrame,PredictVariable="",Backtest=TRUE,Debug=TRUE,TestingSet=FALSE,RegressionModel="",Variable="",RegType="")
{
  
  if (TestingSet == FALSE)
  {
    Title = paste("Training Data with",RegressionModel,"model predicting",Variable)
    if (Debug==TRUE) {print(paste("Post processing training data after running",RegressionModel,"model predicting",Variable))}
  } else {
    Title = paste("Testing Data with",RegressionModel,"model predicting",Variable)
    if (Debug==TRUE) {print(paste("Post processing testing data after running",RegressionModel,"model predicting",Variable))}
  }
  
  PredictVariable1 <- DataFrame[,PredictVariable]
  DataFrame$Actual <- PredictVariable1
  
  # Handle x y type regression results
  if (RegType =="regression")
  {
    # reformat data
    DataFrame$Error <- DataFrame$Prediction - DataFrame$Actual
    
    # Calculate the RMSE and return it as part of the function
    RMSE <- sqrt(sum(DataFrame$Error^2))
    ReturnDataFrame <- data.frame(Desc="RMS Error",RMSE=RMSE)
    
    # Now plot the results
    ResultsPlot <- ggplot(DataFrame,aes(x=Actual,y=Prediction)) +
      geom_point(aes(x=Actual,y=Prediction),
                 colour="Blue",
                 fill="DarkBlue") +
      geom_smooth(method="lm") +
      xlab("Actual Value") +
      ylab("Prediction") +
      theme(plot.title = element_text(size = 12),
            axis.title.x = element_text(size = 10),
            axis.title.y = element_text(size = 10),
            text = element_text(size = 8)) +
      ggtitle(paste("Actual versus Predicted - ",Title))
    print(ResultsPlot)
    
  }
  
  # Handle classification problems
  if (RegType =="classification")
  {
    # Work out if not equal
    DataFrame$Error <- ifelse(DataFrame$Prediction == PredictVariable, 1, 0)
    print(DataFrame)
    
    # find errors
    ErrorsFrame <- subset(DataFrame,DataFrame$Prediction != DataFrame$Actual)
    print(paste("Number of rows predicted",nrow(DataFrame)))
    print(paste("Number of errors found",nrow(ErrorsFrame)))
    
    
    ReturnDataFrame <- ErrorsFrame
    
  }
  
  
  
  return(ReturnDataFrame)
}

ImportancePlot <- function(Model,Title="",SubTitle="",Caption="")
{
  
  library(ggplot2)
  
  MeanDecreaseGini <- importance(Model)
  MeanDecreaseGini <- as.data.frame(MeanDecreaseGini)
  MeanDecreaseGini$Variable <- rownames(MeanDecreaseGini)
  
  ImpPlot <- ggplot(data = MeanDecreaseGini, aes(Variable, IncNodePurity)) +
    geom_bar(stat = "identity", position = "dodge",colour="red",alpha=0.8,fill="red") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    labs(caption = Caption) +
    ggtitle(Title,
            subtitle = paste(SubTitle)) 
  print(ImpPlot)
}


###############################################################################
#
#   Main code
#
###############################################################################

# Load data
DataFrame <- DataLoadAndFormat(Backtest=TRUE,Debug=TRUE)

if (nrow(DataFrame)>0) 
{
  # Pre-Process
  ListOfDataFrames <- PreProcess(DataFrame,ColumnsToSelectForTraining,
                                 DisplayColumnNames,
                                 Backtest=TRUE,
                                 Debug=TRUE,SplitPercent)
  
  # Analyse Data
  DataAnalysis(ListOfDataFrames[[1]])
  
  if (RegressionModel == "SVM")
  {
    print("Training with Support Vector Machine")
    
    # Training
    Model <-     TrainingModelSVM(ListOfDataFrames[[1]],
                                  VariableNames,
                                  PredictVariable=PredictionVariable,
                                  NTrees=NumberOfTrees,
                                  SaveModel=FALSE,
                                  PlotImportance=TRUE)
    
    # Predict from training
    TrainingPredictions <- PredictSVM(ListOfDataFrames[[1]],
                                      VariableNames,
                                      Model,
                                      Backtest=TRUE,
                                      Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TrainingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=FALSE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType)
    
    
    # Predict testing set
    TestingPredictions <- PredictSVM(ListOfDataFrames[[2]],VariableNames,
                                     Model,
                                     Backtest=TRUE,
                                     Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TestingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=TRUE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType)
    print(ResultsDataFrame)
  }
  
  if (RegressionModel == "RF")
  {
    
    print("Training with Random Forrest - Original version")
    
    # Training
    Model <-     TrainingModelRF(ListOfDataFrames[[1]],
                                 VariableNames,
                                 PredictVariable=PredictionVariable,
                                 NTrees=NumberOfTrees,
                                 SaveModel=FALSE,
                                 PlotImportance=TRUE)
    
    # Predict from training
    TrainingPredictions <- PredictRF(ListOfDataFrames[[1]],
                                     VariableNames,
                                     Model,
                                     Backtest=TRUE,
                                     Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TrainingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=FALSE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType)
    
    # Predict testing set
    TestingPredictions <- PredictRF(ListOfDataFrames[[2]],VariableNames,
                                    Model,
                                    Backtest=TRUE,
                                    Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TestingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=TRUE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType)
    print(ResultsDataFrame)
  }
  
  if (RegressionModel == "RFRLT")
  {
    print("Training with Random Forrest - RLT version")
    
    # Training
    Model <-     TrainingModelRFRLT(ListOfDataFrames[[1]],
                                    VariableNames,
                                    PredictVariable=PredictionVariable,
                                    NTrees=NumberOfTrees,
                                    SaveModel=FALSE,
                                    PlotImportance=TRUE,RegType=RegressionType)
    
    # Predict from training
    TrainingPredictions <- PredictRFRLT(ListOfDataFrames[[1]],
                                        VariableNames,
                                        Model,
                                        Backtest=TRUE,
                                        Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TrainingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=FALSE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType)
    
    # Predict testing set
    TestingPredictions <- PredictRFRLT(ListOfDataFrames[[2]],VariableNames,
                                       Model,
                                       Backtest=TRUE,
                                       Debug=TRUE)
    
    # Do results processing
    ResultsDataFrame <- PostProcess(TestingPredictions,PredictVariable=PredictionVariable,
                                    Backtest=TRUE,Debug=TRUE,TestingSet=TRUE,
                                    RegressionModel=RegressionModel,Variable = PredictionVariable,
                                    RegType=RegressionType)
    
    print(ResultsDataFrame)
  }
  
} else {
  print("No data found")
}
